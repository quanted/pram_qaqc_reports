<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <style>body {
	font-family: Helvetica, Arial, sans-serif;
	font-size: 12px;
	min-width: 1200px;
	color: #999;
}
h2 {
	font-size: 16px;
	color: black;
}

p {
    color: black;
}

a {
	color: #999;
}

table {
	border-collapse: collapse;
}

/******************************
 * SUMMARY INFORMATION
 ******************************/

#environment td {
	padding: 5px;
	border: 1px solid #E6E6E6;
}

#environment tr:nth-child(odd) {
	background-color: #f6f6f6;
}

/******************************
 * TEST RESULT COLORS
 ******************************/
span.passed, .passed .col-result {
	color: green;
}
span.skipped, span.xfailed, span.rerun, .skipped .col-result, .xfailed .col-result, .rerun .col-result {
	color: orange;
}
span.error, span.failed, span.xpassed, .error .col-result, .failed .col-result, .xpassed .col-result  {
	color: red;
}


/******************************
 * RESULTS TABLE
 *
 * 1. Table Layout
 * 2. Extra
 * 3. Sorting items
 *
 ******************************/

/*------------------
 * 1. Table Layout
 *------------------*/

#results-table {
	border: 1px solid #e6e6e6;
	color: #999;
	font-size: 12px;
	width: 100%
}

#results-table th, #results-table td {
	padding: 5px;
	border: 1px solid #E6E6E6;
	text-align: left
}
#results-table th {
	font-weight: bold
}

/*------------------
 * 2. Extra
 *------------------*/

.log:only-child {
	height: inherit
}
.log {
	background-color: #e6e6e6;
	border: 1px solid #e6e6e6;
	color: black;
	display: block;
	font-family: "Courier New", Courier, monospace;
	height: 230px;
	overflow-y: scroll;
	padding: 5px;
	white-space: pre-wrap
}
div.image {
	border: 1px solid #e6e6e6;
	float: right;
	height: 240px;
	margin-left: 5px;
	overflow: hidden;
	width: 320px
}
div.image img {
	width: 320px
}
.collapsed {
	display: none;
}
.expander::after {
	content: " (show details)";
	color: #BBB;
	font-style: italic;
	cursor: pointer;
}
.collapser::after {
	content: " (hide details)";
	color: #BBB;
	font-style: italic;
	cursor: pointer;
}

/*------------------
 * 3. Sorting items
 *------------------*/
.sortable {
	cursor: pointer;
}

.sort-icon {
	font-size: 0px;
	float: left;
	margin-right: 5px;
	margin-top: 5px;
	/*triangle*/
	width: 0;
	height: 0;
	border-left: 8px solid transparent;
	border-right: 8px solid transparent;
}

.inactive .sort-icon {
	/*finish triangle*/
	border-top: 8px solid #E6E6E6;
}

.asc.active .sort-icon {
	/*finish triangle*/
	border-bottom: 8px solid #999;
}

.desc.active .sort-icon {
	/*finish triangle*/
	border-top: 8px solid #999;
}
</style></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function find_all(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sort_column(elem) {
    toggle_sort_states(elem);
    var colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    var key;
    if (elem.classList.contains('numeric')) {
        key = key_num;
    } else if (elem.classList.contains('result')) {
        key = key_result;
    } else {
        key = key_alpha;
    }
    sort_table(elem, key(colIndex));
}

function show_all_extras() {
    find_all('.col-result').forEach(show_extras);
}

function hide_all_extras() {
    find_all('.col-result').forEach(hide_extras);
}

function show_extras(colresult_elem) {
    var extras = colresult_elem.parentNode.nextElementSibling;
    var expandcollapse = colresult_elem.firstElementChild;
    extras.classList.remove("collapsed");
    expandcollapse.classList.remove("expander");
    expandcollapse.classList.add("collapser");
}

function hide_extras(colresult_elem) {
    var extras = colresult_elem.parentNode.nextElementSibling;
    var expandcollapse = colresult_elem.firstElementChild;
    extras.classList.add("collapsed");
    expandcollapse.classList.remove("collapser");
    expandcollapse.classList.add("expander");
}

function show_filters() {
    var filter_items = document.getElementsByClassName('filter');
    for (var i = 0; i < filter_items.length; i++)
        filter_items[i].hidden = false;
}

function add_collapse() {
    // Add links for show/hide all
    var resulttable = find('table#results-table');
    var showhideall = document.createElement("p");
    showhideall.innerHTML = '<a href="javascript:show_all_extras()">Show all details</a> / ' +
                            '<a href="javascript:hide_all_extras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    find_all('.col-result').forEach(function(elem) {
        var extras = elem.parentNode.nextElementSibling;
        var expandcollapse = document.createElement("span");
        if (elem.innerHTML === 'Passed') {
            extras.classList.add("collapsed");
            expandcollapse.classList.add("expander");
        } else {
            expandcollapse.classList.add("collapser");
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener("click", function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains("collapsed")) {
                show_extras(event.currentTarget);
            } else {
                hide_extras(event.currentTarget);
            }
        });
    })
}

function init () {
    reset_sort_headers();

    add_collapse();

    show_filters();

    toggle_sort_states(find('.initial-sort'));

    find_all('.sortable').forEach(function(elem) {
        elem.addEventListener("click",
                              function(event) {
                                  sort_column(elem);
                              }, false)
    });

};

function sort_table(clicked, key_func) {
    var rows = find_all('.results-table-row');
    var reversed = !clicked.classList.contains('asc');
    var sorted_rows = sort(rows, key_func, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    var thead = document.getElementById("results-table-head");
    document.getElementById('results-table').remove();
    var parent = document.createElement("table");
    parent.id = "results-table";
    parent.appendChild(thead);
    sorted_rows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName("BODY")[0].appendChild(parent);
}

function sort(items, key_func, reversed) {
    var sort_array = items.map(function(item, i) {
        return [key_func(item), i];
    });
    var multiplier = reversed ? -1 : 1;

    sort_array.sort(function(a, b) {
        var key_a = a[0];
        var key_b = b[0];
        return multiplier * (key_a >= key_b ? 1 : -1);
    });

    return sort_array.map(function(item) {
        var index = item[1];
        return items[index];
    });
}

function key_alpha(col_index) {
    return function(elem) {
        return elem.childNodes[1].childNodes[col_index].firstChild.data.toLowerCase();
    };
}

function key_num(col_index) {
    return function(elem) {
        return parseFloat(elem.childNodes[1].childNodes[col_index].firstChild.data);
    };
}

function key_result(col_index) {
    return function(elem) {
        var strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
                       'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[col_index].firstChild.data);
    };
}

function reset_sort_headers() {
    find_all('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    find_all('.sortable').forEach(function(elem) {
        var icon = document.createElement("div");
        icon.className = "sort-icon";
        icon.textContent = "vvv";
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove("desc", "active");
        elem.classList.add("asc", "inactive");
    });
}

function toggle_sort_states(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        reset_sort_headers();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function is_all_rows_hidden(value) {
  return value.hidden == false;
}

function filter_table(elem) {
    var outcome_att = "data-test-result";
    var outcome = elem.getAttribute(outcome_att);
    class_outcome = outcome + " results-table-row";
    var outcome_rows = document.getElementsByClassName(class_outcome);

    for(var i = 0; i < outcome_rows.length; i++){
        outcome_rows[i].hidden = !elem.checked;
    }

    var rows = find_all('.results-table-row').filter(is_all_rows_hidden);
    var all_rows_hidden = rows.length == 0 ? true : false;
    var not_found_message = document.getElementById("not-found-message");
    not_found_message.hidden = !all_rows_hidden;
}
</script>
    <p>Report generated on 26-Mar-2018 at 14:23:01 by<a href="https://pypi.python.org/pypi/pytest-html"> pytest-html</a> v1.16.1</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Packages</td>
        <td>{&apos;pytest&apos;: &apos;3.4.2&apos;, &apos;py&apos;: &apos;1.5.2&apos;, &apos;pluggy&apos;: &apos;0.6.0&apos;}</td></tr>
      <tr>
        <td>Platform</td>
        <td>Windows-10-10.0.14393-SP0</td></tr>
      <tr>
        <td>Plugins</td>
        <td>{&apos;metadata&apos;: &apos;1.6.0&apos;, &apos;html&apos;: &apos;1.16.1&apos;, &apos;celery&apos;: &apos;4.1.0&apos;}</td></tr>
      <tr>
        <td>Python</td>
        <td>3.6.3</td></tr></table>
    <h2>Summary</h2>
    <p>119 tests ran in 81.33 seconds. </p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="passed">54 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="failed">65 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filter_table(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="name">Test</th>
          <th class="sortable numeric" col="duration">Duration</th>
          <th>Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="4">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_ad_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_ad_acute_rq&gt;<br/><br/>    def test_ad_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.ad_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;ad_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:544: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.009914,      nan,      nan, 1.25894 ,</span><br/><span class="error">E                  0.045956,      nan, 8.118184,      nan])</span><br/><span class="error">E            y: array([1.623429e+01, 1.254715e-03, 9.914064e-03, 1.457001e+01,</span><br/><span class="error">E                  1.171951e+00, 1.258940e+00, 4.595584e-02, 4.170367e-02,</span><br/><span class="error">E                  8.118184e+00, 3.148400e+01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═══════════════════╤═══════════════════╕
│    │   out_ad_acute_rq │   exp_ad_acute_rq │
╞════╪═══════════════════╪═══════════════════╡
│  0 │      nan          │       16.2343     │
├────┼───────────────────┼───────────────────┤
│  1 │      nan          │        0.00125471 │
├────┼───────────────────┼───────────────────┤
│  2 │        0.00991406 │        0.00991406 │
├────┼───────────────────┼───────────────────┤
│  3 │      nan          │       14.57       │
├────┼───────────────────┼───────────────────┤
│  4 │      nan          │        1.17195    │
├────┼───────────────────┼───────────────────┤
│  5 │        1.25894    │        1.25894    │
├────┼───────────────────┼───────────────────┤
│  6 │        0.0459558  │        0.0459558  │
├────┼───────────────────┼───────────────────┤
│  7 │      nan          │        0.0417037  │
├────┼───────────────────┼───────────────────┤
│  8 │        8.11818    │        8.11818    │
├────┼───────────────────┼───────────────────┤
│  9 │      nan          │       31.484      │
╘════╧═══════════════════╧═══════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_ad_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_ad_chronic_rq&gt;<br/><br/>    def test_ad_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.ad_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;ad_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:716: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.013219,      nan,      nan, 0.597463,</span><br/><span class="error">E                  0.449568,      nan, 1.653704,      nan])</span><br/><span class="error">E            y: array([3.957109e+02, 1.463834e-02, 1.321875e-02, 5.008442e+01,</span><br/><span class="error">E                  2.511323e+00, 5.974632e-01, 4.495680e-01, 2.524170e-02,</span><br/><span class="error">E                  1.653704e+00, 4.547689e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═════════════════════╤═════════════════════╕
│    │   out_ad_chronic_rq │   exp_ad_chronic_rq │
╞════╪═════════════════════╪═════════════════════╡
│  0 │         nan         │         395.711     │
├────┼─────────────────────┼─────────────────────┤
│  1 │         nan         │           0.0146383 │
├────┼─────────────────────┼─────────────────────┤
│  2 │           0.0132188 │           0.0132188 │
├────┼─────────────────────┼─────────────────────┤
│  3 │         nan         │          50.0844    │
├────┼─────────────────────┼─────────────────────┤
│  4 │         nan         │           2.51132   │
├────┼─────────────────────┼─────────────────────┤
│  5 │           0.597463  │           0.597463  │
├────┼─────────────────────┼─────────────────────┤
│  6 │           0.449568  │           0.449568  │
├────┼─────────────────────┼─────────────────────┤
│  7 │         nan         │           0.0252417 │
├────┼─────────────────────┼─────────────────────┤
│  8 │           1.6537    │           1.6537    │
├────┼─────────────────────┼─────────────────────┤
│  9 │         nan         │           4.54769   │
╘════╧═════════════════════╧═════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_ad_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_ad_total_dose&gt;<br/><br/>    def test_ad_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.ad_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;ad_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:370: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.006345,      nan,      nan, 0.352503,</span><br/><span class="error">E                  0.206801,      nan, 0.893   ,      nan])</span><br/><span class="error">E            y: array([6.331375e-02, 4.391500e-04, 6.345001e-03, 1.602701e+02,</span><br/><span class="error">E                  2.109511e+00, 3.525033e-01, 2.068013e-01, 9.591845e-02,</span><br/><span class="error">E                  8.930003e-01, 2.455752e+01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═════════════════════╤═════════════════════╕
│    │   out_ad_total_dose │   exp_ad_total_dose │
╞════╪═════════════════════╪═════════════════════╡
│  0 │          nan        │          0.0633137  │
├────┼─────────────────────┼─────────────────────┤
│  1 │          nan        │          0.00043915 │
├────┼─────────────────────┼─────────────────────┤
│  2 │            0.006345 │          0.006345   │
├────┼─────────────────────┼─────────────────────┤
│  3 │          nan        │        160.27       │
├────┼─────────────────────┼─────────────────────┤
│  4 │          nan        │          2.10951    │
├────┼─────────────────────┼─────────────────────┤
│  5 │            0.352503 │          0.352503   │
├────┼─────────────────────┼─────────────────────┤
│  6 │            0.206801 │          0.206801   │
├────┼─────────────────────┼─────────────────────┤
│  7 │          nan        │          0.0959184  │
├────┼─────────────────────┼─────────────────────┤
│  8 │            0.893    │          0.893      │
├────┼─────────────────────┼─────────────────────┤
│  9 │          nan        │         24.5575     │
╘════╧═════════════════════╧═════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aq_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aq_acute_rq&gt;<br/><br/>    def test_aq_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aq_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aq_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:553: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 4.921875e-04,          nan,</span><br/><span class="error">E                           nan, 3.562500e+00, 1.656667e-01,          nan,</span><br/><span class="error">E                  3.722727e+00,          nan])</span><br/><span class="error">E            y: array([3.626807e-01, 2.803080e-05, 4.921880e-04, 3.255000e-01,</span><br/><span class="error">E                  2.618186e-02, 3.562500e+00, 1.656667e-01, 9.316770e-04,</span><br/><span class="error">E                  3.722727e+00, 7.033654e-01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═══════════════════╤═══════════════════╕
│    │   out_aq_acute_rq │   exp_aq_acute_rq │
╞════╪═══════════════════╪═══════════════════╡
│  0 │     nan           │       0.362681    │
├────┼───────────────────┼───────────────────┤
│  1 │     nan           │       2.80308e-05 │
├────┼───────────────────┼───────────────────┤
│  2 │       0.000492187 │       0.000492188 │
├────┼───────────────────┼───────────────────┤
│  3 │     nan           │       0.3255      │
├────┼───────────────────┼───────────────────┤
│  4 │     nan           │       0.0261819   │
├────┼───────────────────┼───────────────────┤
│  5 │       3.5625      │       3.5625      │
├────┼───────────────────┼───────────────────┤
│  6 │       0.165667    │       0.165667    │
├────┼───────────────────┼───────────────────┤
│  7 │     nan           │       0.000931677 │
├────┼───────────────────┼───────────────────┤
│  8 │       3.72273     │       3.72273     │
├────┼───────────────────┼───────────────────┤
│  9 │     nan           │       0.703365    │
╘════╧═══════════════════╧═══════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aq_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aq_chronic_rq&gt;<br/><br/>    def test_aq_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aq_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aq_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:725: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 6.562500e-04,          nan,</span><br/><span class="error">E                           nan, 1.690678e+00, 1.620652e+00,          nan,</span><br/><span class="error">E                  7.583333e-01,          nan])</span><br/><span class="error">E            y: array([8.840343e+00, 3.270260e-04, 6.562500e-04, 1.118906e+00,</span><br/><span class="error">E                  5.610398e-02, 1.690678e+00, 1.620652e+00, 5.639100e-04,</span><br/><span class="error">E                  7.583333e-01, 1.015972e-01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═════════════════════╤═════════════════════╕
│    │   out_aq_chronic_rq │   exp_aq_chronic_rq │
╞════╪═════════════════════╪═════════════════════╡
│  0 │        nan          │         8.84034     │
├────┼─────────────────────┼─────────────────────┤
│  1 │        nan          │         0.000327026 │
├────┼─────────────────────┼─────────────────────┤
│  2 │          0.00065625 │         0.00065625  │
├────┼─────────────────────┼─────────────────────┤
│  3 │        nan          │         1.11891     │
├────┼─────────────────────┼─────────────────────┤
│  4 │        nan          │         0.056104    │
├────┼─────────────────────┼─────────────────────┤
│  5 │          1.69068    │         1.69068     │
├────┼─────────────────────┼─────────────────────┤
│  6 │          1.62065    │         1.62065     │
├────┼─────────────────────┼─────────────────────┤
│  7 │        nan          │         0.00056391  │
├────┼─────────────────────┼─────────────────────┤
│  8 │          0.758333   │         0.758333    │
├────┼─────────────────────┼─────────────────────┤
│  9 │        nan          │         0.101597    │
╘════╧═════════════════════╧═════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aq_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aq_total_dose&gt;<br/><br/>    def test_aq_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aq_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aq_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:380: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([      nan,       nan, 3.150e-04,       nan,       nan, 9.975e-01,</span><br/><span class="error">E                  7.455e-01,       nan, 4.095e-01,       nan])</span><br/><span class="error">E            y: array([1.414455e-03, 9.810790e-06, 3.150000e-04, 3.580500e+00,</span><br/><span class="error">E                  4.712734e-02, 9.975000e-01, 7.455000e-01, 2.142857e-03,</span><br/><span class="error">E                  4.095000e-01, 5.486250e-01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═════════════════════╤═════════════════════╕
│    │   out_aq_total_dose │   exp_aq_total_dose │
╞════╪═════════════════════╪═════════════════════╡
│  0 │          nan        │         0.00141446  │
├────┼─────────────────────┼─────────────────────┤
│  1 │          nan        │         9.81079e-06 │
├────┼─────────────────────┼─────────────────────┤
│  2 │            0.000315 │         0.000315    │
├────┼─────────────────────┼─────────────────────┤
│  3 │          nan        │         3.5805      │
├────┼─────────────────────┼─────────────────────┤
│  4 │          nan        │         0.0471273   │
├────┼─────────────────────┼─────────────────────┤
│  5 │            0.9975   │         0.9975      │
├────┼─────────────────────┼─────────────────────┤
│  6 │            0.7455   │         0.7455      │
├────┼─────────────────────┼─────────────────────┤
│  7 │          nan        │         0.00214286  │
├────┼─────────────────────┼─────────────────────┤
│  8 │            0.4095   │         0.4095      │
├────┼─────────────────────┼─────────────────────┤
│  9 │          nan        │         0.548625    │
╘════╧═════════════════════╧═════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_brood_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_brood_acute_rq&gt;<br/><br/>    def test_aw_brood_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_brood_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_brood_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:499: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.005957,      nan,      nan, 1.312286,</span><br/><span class="error">E                  0.041244,      nan, 4.958545,      nan])</span><br/><span class="error">E            y: array([1.033467e+01, 7.987450e-04, 5.957250e-03, 9.275200e+00,</span><br/><span class="error">E                  7.460582e-01, 1.312286e+00, 4.124444e-02, 2.654836e-02,</span><br/><span class="error">E                  4.958545e+00, 2.004256e+01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═════════════════════════╤═════════════════════════╕
│    │   out_aw_brood_acute_rq │   exp_aw_brood_acute_rq │
╞════╪═════════════════════════╪═════════════════════════╡
│  0 │            nan          │            10.3347      │
├────┼─────────────────────────┼─────────────────────────┤
│  1 │            nan          │             0.000798745 │
├────┼─────────────────────────┼─────────────────────────┤
│  2 │              0.00595725 │             0.00595725  │
├────┼─────────────────────────┼─────────────────────────┤
│  3 │            nan          │             9.2752      │
├────┼─────────────────────────┼─────────────────────────┤
│  4 │            nan          │             0.746058    │
├────┼─────────────────────────┼─────────────────────────┤
│  5 │              1.31229    │             1.31229     │
├────┼─────────────────────────┼─────────────────────────┤
│  6 │              0.0412444  │             0.0412444   │
├────┼─────────────────────────┼─────────────────────────┤
│  7 │            nan          │             0.0265484   │
├────┼─────────────────────────┼─────────────────────────┤
│  8 │              4.95855    │             4.95855     │
├────┼─────────────────────────┼─────────────────────────┤
│  9 │            nan          │            20.0426      │
╘════╧═════════════════════════╧═════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_brood_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_brood_chronic_rq&gt;<br/><br/>    def test_aw_brood_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_brood_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_brood_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:671: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.007943,      nan,      nan, 0.62278 ,</span><br/><span class="error">E                  0.403478,      nan, 1.010074,      nan])</span><br/><span class="error">E            y: array([2.519077e+02, 9.318695e-03, 7.943000e-03, 3.188350e+01,</span><br/><span class="error">E                  1.598696e+00, 6.227797e-01, 4.034783e-01, 1.606874e-02,</span><br/><span class="error">E                  1.010074e+00, 2.895037e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═══════════════════════════╤═══════════════════════════╕
│    │   out_aw_brood_chronic_rq │   exp_aw_brood_chronic_rq │
╞════╪═══════════════════════════╪═══════════════════════════╡
│  0 │                nan        │               251.908     │
├────┼───────────────────────────┼───────────────────────────┤
│  1 │                nan        │                 0.0093187 │
├────┼───────────────────────────┼───────────────────────────┤
│  2 │                  0.007943 │                 0.007943  │
├────┼───────────────────────────┼───────────────────────────┤
│  3 │                nan        │                31.8835    │
├────┼───────────────────────────┼───────────────────────────┤
│  4 │                nan        │                 1.5987    │
├────┼───────────────────────────┼───────────────────────────┤
│  5 │                  0.62278  │                 0.62278   │
├────┼───────────────────────────┼───────────────────────────┤
│  6 │                  0.403478 │                 0.403478  │
├────┼───────────────────────────┼───────────────────────────┤
│  7 │                nan        │                 0.0160687 │
├────┼───────────────────────────┼───────────────────────────┤
│  8 │                  1.01007  │                 1.01007   │
├────┼───────────────────────────┼───────────────────────────┤
│  9 │                nan        │                 2.89504   │
╘════╧═══════════════════════════╧═══════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_brood_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_brood_total_dose&gt;<br/><br/>    def test_aw_brood_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_brood_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_brood_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:320: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.003813,      nan,      nan, 0.36744 ,</span><br/><span class="error">E                  0.1856  ,      nan, 0.54544 ,      nan])</span><br/><span class="error">E            y: array([4.030523e-02, 2.795610e-04, 3.812640e-03, 1.020272e+02,</span><br/><span class="error">E                  1.342905e+00, 3.674400e-01, 1.856000e-01, 6.106122e-02,</span><br/><span class="error">E                  5.454400e-01, 1.563320e+01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═══════════════════════════╤═══════════════════════════╕
│    │   out_aw_brood_total_dose │   exp_aw_brood_total_dose │
╞════╪═══════════════════════════╪═══════════════════════════╡
│  0 │              nan          │               0.0403052   │
├────┼───────────────────────────┼───────────────────────────┤
│  1 │              nan          │               0.000279561 │
├────┼───────────────────────────┼───────────────────────────┤
│  2 │                0.00381264 │               0.00381264  │
├────┼───────────────────────────┼───────────────────────────┤
│  3 │              nan          │             102.027       │
├────┼───────────────────────────┼───────────────────────────┤
│  4 │              nan          │               1.3429      │
├────┼───────────────────────────┼───────────────────────────┤
│  5 │                0.36744    │               0.36744     │
├────┼───────────────────────────┼───────────────────────────┤
│  6 │                0.1856     │               0.1856      │
├────┼───────────────────────────┼───────────────────────────┤
│  7 │              nan          │               0.0610612   │
├────┼───────────────────────────┼───────────────────────────┤
│  8 │                0.54544    │               0.54544     │
├────┼───────────────────────────┼───────────────────────────┤
│  9 │              nan          │              15.6332      │
╘════╧═══════════════════════════╧═══════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_cell_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_cell_acute_rq&gt;<br/><br/>    def test_aw_cell_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_cell_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_cell_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:490: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.002567,      nan,      nan, 0.710929,</span><br/><span class="error">E                  0.021339,      nan, 2.157364,      nan])</span><br/><span class="error">E            y: array([4.604318e+00, 3.558580e-04, 2.566578e-03, 4.132300e+00,</span><br/><span class="error">E                  3.323849e-01, 7.109286e-01, 2.133889e-02, 1.182786e-02,</span><br/><span class="error">E                  2.157364e+00, 8.929391e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════════╤════════════════════════╕
│    │   out_aw_cell_acute_rq │   exp_aw_cell_acute_rq │
╞════╪════════════════════════╪════════════════════════╡
│  0 │           nan          │            4.60432     │
├────┼────────────────────────┼────────────────────────┤
│  1 │           nan          │            0.000355858 │
├────┼────────────────────────┼────────────────────────┤
│  2 │             0.00256658 │            0.00256658  │
├────┼────────────────────────┼────────────────────────┤
│  3 │           nan          │            4.1323      │
├────┼────────────────────────┼────────────────────────┤
│  4 │           nan          │            0.332385    │
├────┼────────────────────────┼────────────────────────┤
│  5 │             0.710929   │            0.710929    │
├────┼────────────────────────┼────────────────────────┤
│  6 │             0.0213389  │            0.0213389   │
├────┼────────────────────────┼────────────────────────┤
│  7 │           nan          │            0.0118279   │
├────┼────────────────────────┼────────────────────────┤
│  8 │             2.15736    │            2.15736     │
├────┼────────────────────────┼────────────────────────┤
│  9 │           nan          │            8.92939     │
╘════╧════════════════════════╧════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_cell_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_cell_chronic_rq&gt;<br/><br/>    def test_aw_cell_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_cell_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_cell_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:662: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.003422,      nan,      nan, 0.33739 ,</span><br/><span class="error">E                  0.20875 ,      nan, 0.439463,      nan])</span><br/><span class="error">E            y: array([1.122303e+02, 4.151678e-03, 3.422104e-03, 1.420478e+01,</span><br/><span class="error">E                  7.122533e-01, 3.373898e-01, 2.087500e-01, 7.158969e-03,</span><br/><span class="error">E                  4.394630e-01, 1.289801e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════════╤══════════════════════════╕
│    │   out_aw_cell_chronic_rq │   exp_aw_cell_chronic_rq │
╞════╪══════════════════════════╪══════════════════════════╡
│  0 │              nan         │             112.23       │
├────┼──────────────────────────┼──────────────────────────┤
│  1 │              nan         │               0.00415168 │
├────┼──────────────────────────┼──────────────────────────┤
│  2 │                0.0034221 │               0.0034221  │
├────┼──────────────────────────┼──────────────────────────┤
│  3 │              nan         │              14.2048     │
├────┼──────────────────────────┼──────────────────────────┤
│  4 │              nan         │               0.712253   │
├────┼──────────────────────────┼──────────────────────────┤
│  5 │                0.33739   │               0.33739    │
├────┼──────────────────────────┼──────────────────────────┤
│  6 │                0.20875   │               0.20875    │
├────┼──────────────────────────┼──────────────────────────┤
│  7 │              nan         │               0.00715897 │
├────┼──────────────────────────┼──────────────────────────┤
│  8 │                0.439463  │               0.439463   │
├────┼──────────────────────────┼──────────────────────────┤
│  9 │              nan         │               1.2898     │
╘════╧══════════════════════════╧══════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_cell_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_cell_total_dose&gt;<br/><br/>    def test_aw_cell_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_cell_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_cell_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:310: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.001643,      nan,      nan, 0.19906 ,</span><br/><span class="error">E                  0.096025,      nan, 0.23731 ,      nan])</span><br/><span class="error">E            y: array([1.795684e-02, 1.245500e-04, 1.642610e-03, 4.545530e+01,</span><br/><span class="error">E                  5.982928e-01, 1.990600e-01, 9.602500e-02, 2.720408e-02,</span><br/><span class="error">E                  2.373100e-01, 6.964925e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════════╤══════════════════════════╕
│    │   out_aw_cell_total_dose │   exp_aw_cell_total_dose │
╞════╪══════════════════════════╪══════════════════════════╡
│  0 │             nan          │               0.0179568  │
├────┼──────────────────────────┼──────────────────────────┤
│  1 │             nan          │               0.00012455 │
├────┼──────────────────────────┼──────────────────────────┤
│  2 │               0.00164261 │               0.00164261 │
├────┼──────────────────────────┼──────────────────────────┤
│  3 │             nan          │              45.4553     │
├────┼──────────────────────────┼──────────────────────────┤
│  4 │             nan          │               0.598293   │
├────┼──────────────────────────┼──────────────────────────┤
│  5 │               0.19906    │               0.19906    │
├────┼──────────────────────────┼──────────────────────────┤
│  6 │               0.096025   │               0.096025   │
├────┼──────────────────────────┼──────────────────────────┤
│  7 │             nan          │               0.0272041  │
├────┼──────────────────────────┼──────────────────────────┤
│  8 │               0.23731    │               0.23731    │
├────┼──────────────────────────┼──────────────────────────┤
│  9 │             nan          │               6.96493    │
╘════╧══════════════════════════╧══════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_comb_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_comb_acute_rq&gt;<br/><br/>    def test_aw_comb_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_comb_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_comb_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:508: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.00254 ,      nan,      nan, 0.421   ,</span><br/><span class="error">E                  0.014189,      nan, 2.094364,      nan])</span><br/><span class="error">E            y: array([4.262362e+00, 3.294290e-04, 2.540281e-03, 3.825400e+00,</span><br/><span class="error">E                  3.076991e-01, 4.210000e-01, 1.418889e-02, 1.094942e-02,</span><br/><span class="error">E                  2.094364e+00, 8.266218e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════════╤════════════════════════╕
│    │   out_aw_comb_acute_rq │   exp_aw_comb_acute_rq │
╞════╪════════════════════════╪════════════════════════╡
│  0 │           nan          │            4.26236     │
├────┼────────────────────────┼────────────────────────┤
│  1 │           nan          │            0.000329429 │
├────┼────────────────────────┼────────────────────────┤
│  2 │             0.00254028 │            0.00254028  │
├────┼────────────────────────┼────────────────────────┤
│  3 │           nan          │            3.8254      │
├────┼────────────────────────┼────────────────────────┤
│  4 │           nan          │            0.307699    │
├────┼────────────────────────┼────────────────────────┤
│  5 │             0.421      │            0.421       │
├────┼────────────────────────┼────────────────────────┤
│  6 │             0.0141889  │            0.0141889   │
├────┼────────────────────────┼────────────────────────┤
│  7 │           nan          │            0.0109494   │
├────┼────────────────────────┼────────────────────────┤
│  8 │             2.09436    │            2.09436     │
├────┼────────────────────────┼────────────────────────┤
│  9 │           nan          │            8.26622     │
╘════╧════════════════════════╧════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_comb_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_comb_chronic_rq&gt;<br/><br/>    def test_aw_comb_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_comb_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_comb_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:680: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.003387,      nan,      nan, 0.199797,</span><br/><span class="error">E                  0.138804,      nan, 0.42663 ,      nan])</span><br/><span class="error">E            y: array([1.038951e+02, 3.843339e-03, 3.387042e-03, 1.314981e+01,</span><br/><span class="error">E                  6.593553e-01, 1.997966e-01, 1.388043e-01, 6.627282e-03,</span><br/><span class="error">E                  4.266296e-01, 1.194009e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════════╤══════════════════════════╕
│    │   out_aw_comb_chronic_rq │   exp_aw_comb_chronic_rq │
╞════╪══════════════════════════╪══════════════════════════╡
│  0 │             nan          │             103.895      │
├────┼──────────────────────────┼──────────────────────────┤
│  1 │             nan          │               0.00384334 │
├────┼──────────────────────────┼──────────────────────────┤
│  2 │               0.00338704 │               0.00338704 │
├────┼──────────────────────────┼──────────────────────────┤
│  3 │             nan          │              13.1498     │
├────┼──────────────────────────┼──────────────────────────┤
│  4 │             nan          │               0.659355   │
├────┼──────────────────────────┼──────────────────────────┤
│  5 │               0.199797   │               0.199797   │
├────┼──────────────────────────┼──────────────────────────┤
│  6 │               0.138804   │               0.138804   │
├────┼──────────────────────────┼──────────────────────────┤
│  7 │             nan          │               0.00662728 │
├────┼──────────────────────────┼──────────────────────────┤
│  8 │               0.42663    │               0.42663    │
├────┼──────────────────────────┼──────────────────────────┤
│  9 │             nan          │               1.19401    │
╘════╧══════════════════════════╧══════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_comb_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_comb_total_dose&gt;<br/><br/>    def test_aw_comb_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_comb_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_comb_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:330: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.001626,      nan,      nan, 0.11788 ,</span><br/><span class="error">E                  0.06385 ,      nan, 0.23038 ,      nan])</span><br/><span class="error">E            y: array([1.662321e-02, 1.153000e-04, 1.625780e-03, 4.207940e+01,</span><br/><span class="error">E                  5.538584e-01, 1.178800e-01, 6.385000e-02, 2.518367e-02,</span><br/><span class="error">E                  2.303800e-01, 6.447650e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════════╤══════════════════════════╕
│    │   out_aw_comb_total_dose │   exp_aw_comb_total_dose │
╞════╪══════════════════════════╪══════════════════════════╡
│  0 │             nan          │               0.0166232  │
├────┼──────────────────────────┼──────────────────────────┤
│  1 │             nan          │               0.0001153  │
├────┼──────────────────────────┼──────────────────────────┤
│  2 │               0.00162578 │               0.00162578 │
├────┼──────────────────────────┼──────────────────────────┤
│  3 │             nan          │              42.0794     │
├────┼──────────────────────────┼──────────────────────────┤
│  4 │             nan          │               0.553858   │
├────┼──────────────────────────┼──────────────────────────┤
│  5 │               0.11788    │               0.11788    │
├────┼──────────────────────────┼──────────────────────────┤
│  6 │               0.06385    │               0.06385    │
├────┼──────────────────────────┼──────────────────────────┤
│  7 │             nan          │               0.0251837  │
├────┼──────────────────────────┼──────────────────────────┤
│  8 │               0.23038    │               0.23038    │
├────┼──────────────────────────┼──────────────────────────┤
│  9 │             nan          │               6.44765    │
╘════╧══════════════════════════╧══════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_nectar_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_nectar_acute_rq&gt;<br/><br/>    def test_aw_nectar_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_nectar_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_nectar_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:526: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([      nan,       nan,  0.012319,       nan,       nan,  1.566687,</span><br/><span class="error">E                   0.057161,       nan, 10.087795,       nan])</span><br/><span class="error">E            y: array([2.017479e+01, 1.559267e-03, 1.231897e-02, 1.810654e+01,</span><br/><span class="error">E                  1.456414e+00, 1.566687e+00, 5.716144e-02, 5.182626e-02,</span><br/><span class="error">E                  1.008779e+01, 3.912601e+01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════════╤══════════════════════════╕
│    │   out_aw_nectar_acute_rq │   exp_aw_nectar_acute_rq │
╞════╪══════════════════════════╪══════════════════════════╡
│  0 │              nan         │              20.1748     │
├────┼──────────────────────────┼──────────────────────────┤
│  1 │              nan         │               0.00155927 │
├────┼──────────────────────────┼──────────────────────────┤
│  2 │                0.012319  │               0.012319   │
├────┼──────────────────────────┼──────────────────────────┤
│  3 │              nan         │              18.1065     │
├────┼──────────────────────────┼──────────────────────────┤
│  4 │              nan         │               1.45641    │
├────┼──────────────────────────┼──────────────────────────┤
│  5 │                1.56669   │               1.56669    │
├────┼──────────────────────────┼──────────────────────────┤
│  6 │                0.0571614 │               0.0571614  │
├────┼──────────────────────────┼──────────────────────────┤
│  7 │              nan         │               0.0518263  │
├────┼──────────────────────────┼──────────────────────────┤
│  8 │               10.0878    │              10.0878     │
├────┼──────────────────────────┼──────────────────────────┤
│  9 │              nan         │              39.126      │
╘════╧══════════════════════════╧══════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_nectar_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_nectar_chronic_rq&gt;<br/><br/>    def test_aw_nectar_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_nectar_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_nectar_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:698: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.016425,      nan,      nan, 0.743513,</span><br/><span class="error">E                  0.559188,      nan, 2.054921,      nan])</span><br/><span class="error">E            y: array([4.917605e+02, 1.819145e-02, 1.642529e-02, 6.224124e+01,</span><br/><span class="error">E                  3.120888e+00, 7.435125e-01, 5.591880e-01, 3.136853e-02,</span><br/><span class="error">E                  2.054921e+00, 5.651534e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════════════╤════════════════════════════╕
│    │   out_aw_nectar_chronic_rq │   exp_aw_nectar_chronic_rq │
╞════╪════════════════════════════╪════════════════════════════╡
│  0 │                nan         │                491.76      │
├────┼────────────────────────────┼────────────────────────────┤
│  1 │                nan         │                  0.0181915 │
├────┼────────────────────────────┼────────────────────────────┤
│  2 │                  0.0164253 │                  0.0164253 │
├────┼────────────────────────────┼────────────────────────────┤
│  3 │                nan         │                 62.2412    │
├────┼────────────────────────────┼────────────────────────────┤
│  4 │                nan         │                  3.12089   │
├────┼────────────────────────────┼────────────────────────────┤
│  5 │                  0.743513  │                  0.743513  │
├────┼────────────────────────────┼────────────────────────────┤
│  6 │                  0.559188  │                  0.559188  │
├────┼────────────────────────────┼────────────────────────────┤
│  7 │                nan         │                  0.0313685 │
├────┼────────────────────────────┼────────────────────────────┤
│  8 │                  2.05492   │                  2.05492   │
├────┼────────────────────────────┼────────────────────────────┤
│  9 │                nan         │                  5.65153   │
╘════╧════════════════════════════╧════════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_nectar_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_nectar_total_dose&gt;<br/><br/>    def test_aw_nectar_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_nectar_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_nectar_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:350: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.007884,      nan,      nan, 0.438672,</span><br/><span class="error">E                  0.257227,      nan, 1.109657,      nan])</span><br/><span class="error">E            y: array([7.868168e-02, 5.457440e-04, 7.884139e-03, 1.991720e+02,</span><br/><span class="error">E                  2.621546e+00, 4.386724e-01, 2.572265e-01, 1.192004e-01,</span><br/><span class="error">E                  1.109657e+00, 3.051828e+01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════════════╤════════════════════════════╕
│    │   out_aw_nectar_total_dose │   exp_aw_nectar_total_dose │
╞════╪════════════════════════════╪════════════════════════════╡
│  0 │               nan          │                0.0786817   │
├────┼────────────────────────────┼────────────────────────────┤
│  1 │               nan          │                0.000545744 │
├────┼────────────────────────────┼────────────────────────────┤
│  2 │                 0.00788414 │                0.00788414  │
├────┼────────────────────────────┼────────────────────────────┤
│  3 │               nan          │              199.172       │
├────┼────────────────────────────┼────────────────────────────┤
│  4 │               nan          │                2.62155     │
├────┼────────────────────────────┼────────────────────────────┤
│  5 │                 0.438672   │                0.438672    │
├────┼────────────────────────────┼────────────────────────────┤
│  6 │                 0.257227   │                0.257226    │
├────┼────────────────────────────┼────────────────────────────┤
│  7 │               nan          │                0.1192      │
├────┼────────────────────────────┼────────────────────────────┤
│  8 │                 1.10966    │                1.10966     │
├────┼────────────────────────────┼────────────────────────────┤
│  9 │               nan          │               30.5183      │
╘════╧════════════════════════════╧════════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_pollen_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_pollen_acute_rq&gt;<br/><br/>    def test_aw_pollen_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_pollen_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_pollen_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:517: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.001835,      nan,      nan, 0.235437,</span><br/><span class="error">E                  0.008566,      nan, 1.503249,      nan])</span><br/><span class="error">E            y: array([3.007901e+00, 2.324740e-04, 1.835374e-03, 2.699542e+00,</span><br/><span class="error">E                  2.171398e-01, 2.354371e-01, 8.565889e-03, 7.726886e-03,</span><br/><span class="error">E                  1.503249e+00, 5.833378e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════════╤══════════════════════════╕
│    │   out_aw_pollen_acute_rq │   exp_aw_pollen_acute_rq │
╞════╪══════════════════════════╪══════════════════════════╡
│  0 │             nan          │              3.0079      │
├────┼──────────────────────────┼──────────────────────────┤
│  1 │             nan          │              0.000232474 │
├────┼──────────────────────────┼──────────────────────────┤
│  2 │               0.00183537 │              0.00183537  │
├────┼──────────────────────────┼──────────────────────────┤
│  3 │             nan          │              2.69954     │
├────┼──────────────────────────┼──────────────────────────┤
│  4 │             nan          │              0.21714     │
├────┼──────────────────────────┼──────────────────────────┤
│  5 │               0.235437   │              0.235437    │
├────┼──────────────────────────┼──────────────────────────┤
│  6 │               0.00856589 │              0.00856589  │
├────┼──────────────────────────┼──────────────────────────┤
│  7 │             nan          │              0.00772689  │
├────┼──────────────────────────┼──────────────────────────┤
│  8 │               1.50325    │              1.50325     │
├────┼──────────────────────────┼──────────────────────────┤
│  9 │             nan          │              5.83338     │
╘════╧══════════════════════════╧══════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_pollen_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_pollen_chronic_rq&gt;<br/><br/>    def test_aw_pollen_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_pollen_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_pollen_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:689: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.002447,      nan,      nan, 0.111733,</span><br/><span class="error">E                  0.083797,      nan, 0.306217,      nan])</span><br/><span class="error">E            y: array([7.331759e+01, 2.712201e-03, 2.447165e-03, 9.279676e+00,</span><br/><span class="error">E                  4.652997e-01, 1.117329e-01, 8.379674e-02, 4.676799e-03,</span><br/><span class="error">E                  3.062174e-01, 8.425990e-01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════════════╤════════════════════════════╕
│    │   out_aw_pollen_chronic_rq │   exp_aw_pollen_chronic_rq │
╞════╪════════════════════════════╪════════════════════════════╡
│  0 │               nan          │                73.3176     │
├────┼────────────────────────────┼────────────────────────────┤
│  1 │               nan          │                 0.0027122  │
├────┼────────────────────────────┼────────────────────────────┤
│  2 │                 0.00244717 │                 0.00244716 │
├────┼────────────────────────────┼────────────────────────────┤
│  3 │               nan          │                 9.27968    │
├────┼────────────────────────────┼────────────────────────────┤
│  4 │               nan          │                 0.4653     │
├────┼────────────────────────────┼────────────────────────────┤
│  5 │                 0.111733   │                 0.111733   │
├────┼────────────────────────────┼────────────────────────────┤
│  6 │                 0.0837967  │                 0.0837967  │
├────┼────────────────────────────┼────────────────────────────┤
│  7 │               nan          │                 0.0046768  │
├────┼────────────────────────────┼────────────────────────────┤
│  8 │                 0.306217   │                 0.306217   │
├────┼────────────────────────────┼────────────────────────────┤
│  9 │               nan          │                 0.842599   │
╘════╧════════════════════════════╧════════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_pollen_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_pollen_total_dose&gt;<br/><br/>    def test_aw_pollen_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_pollen_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_pollen_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:340: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.001175,      nan,      nan, 0.065922,</span><br/><span class="error">E                  0.038547,      nan, 0.165357,      nan])</span><br/><span class="error">E            y: array([1.173082e-02, 8.136600e-05, 1.174639e-03, 2.969496e+01,</span><br/><span class="error">E                  3.908517e-01, 6.592240e-02, 3.854650e-02, 1.777184e-02,</span><br/><span class="error">E                  1.653574e-01, 4.550034e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════════════╤════════════════════════════╕
│    │   out_aw_pollen_total_dose │   exp_aw_pollen_total_dose │
╞════╪════════════════════════════╪════════════════════════════╡
│  0 │               nan          │                 0.0117308  │
├────┼────────────────────────────┼────────────────────────────┤
│  1 │               nan          │                 8.1366e-05 │
├────┼────────────────────────────┼────────────────────────────┤
│  2 │                 0.00117464 │                 0.00117464 │
├────┼────────────────────────────┼────────────────────────────┤
│  3 │               nan          │                29.695      │
├────┼────────────────────────────┼────────────────────────────┤
│  4 │               nan          │                 0.390852   │
├────┼────────────────────────────┼────────────────────────────┤
│  5 │                 0.0659224  │                 0.0659224  │
├────┼────────────────────────────┼────────────────────────────┤
│  6 │                 0.0385465  │                 0.0385465  │
├────┼────────────────────────────┼────────────────────────────┤
│  7 │               nan          │                 0.0177718  │
├────┼────────────────────────────┼────────────────────────────┤
│  8 │                 0.165357   │                 0.165357   │
├────┼────────────────────────────┼────────────────────────────┤
│  9 │               nan          │                 4.55003    │
╘════╧════════════════════════════╧════════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_winter_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_winter_acute_rq&gt;<br/><br/>    def test_aw_winter_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_winter_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_winter_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:535: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.001234,      nan,      nan, 0.2725  ,</span><br/><span class="error">E                  0.00856 ,      nan, 1.027273,      nan])</span><br/><span class="error">E            y: array([2.141543e+00, 1.655150e-04, 1.234063e-03, 1.922000e+00,</span><br/><span class="error">E                  1.545976e-01, 2.725000e-01, 8.560000e-03, 5.501331e-03,</span><br/><span class="error">E                  1.027273e+00, 4.153205e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════════╤══════════════════════════╕
│    │   out_aw_winter_acute_rq │   exp_aw_winter_acute_rq │
╞════╪══════════════════════════╪══════════════════════════╡
│  0 │             nan          │              2.14154     │
├────┼──────────────────────────┼──────────────────────────┤
│  1 │             nan          │              0.000165515 │
├────┼──────────────────────────┼──────────────────────────┤
│  2 │               0.00123406 │              0.00123406  │
├────┼──────────────────────────┼──────────────────────────┤
│  3 │             nan          │              1.922       │
├────┼──────────────────────────┼──────────────────────────┤
│  4 │             nan          │              0.154598    │
├────┼──────────────────────────┼──────────────────────────┤
│  5 │               0.2725     │              0.2725      │
├────┼──────────────────────────┼──────────────────────────┤
│  6 │               0.00856    │              0.00856     │
├────┼──────────────────────────┼──────────────────────────┤
│  7 │             nan          │              0.00550133  │
├────┼──────────────────────────┼──────────────────────────┤
│  8 │               1.02727    │              1.02727     │
├────┼──────────────────────────┼──────────────────────────┤
│  9 │             nan          │              4.15321     │
╘════╧══════════════════════════╧══════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_winter_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_winter_chronic_rq&gt;<br/><br/>    def test_aw_winter_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_winter_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_winter_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:707: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.001645,      nan,      nan, 0.129322,</span><br/><span class="error">E                  0.083739,      nan, 0.209259,      nan])</span><br/><span class="error">E            y: array([5.220012e+01, 1.931013e-03, 1.645417e-03, 6.606875e+00,</span><br/><span class="error">E                  3.312806e-01, 1.293220e-01, 8.373913e-02, 3.329753e-03,</span><br/><span class="error">E                  2.092593e-01, 5.999074e-01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════════════╤════════════════════════════╕
│    │   out_aw_winter_chronic_rq │   exp_aw_winter_chronic_rq │
╞════╪════════════════════════════╪════════════════════════════╡
│  0 │               nan          │                52.2001     │
├────┼────────────────────────────┼────────────────────────────┤
│  1 │               nan          │                 0.00193101 │
├────┼────────────────────────────┼────────────────────────────┤
│  2 │                 0.00164542 │                 0.00164542 │
├────┼────────────────────────────┼────────────────────────────┤
│  3 │               nan          │                 6.60687    │
├────┼────────────────────────────┼────────────────────────────┤
│  4 │               nan          │                 0.331281   │
├────┼────────────────────────────┼────────────────────────────┤
│  5 │                 0.129322   │                 0.129322   │
├────┼────────────────────────────┼────────────────────────────┤
│  6 │                 0.0837391  │                 0.0837391  │
├────┼────────────────────────────┼────────────────────────────┤
│  7 │               nan          │                 0.00332975 │
├────┼────────────────────────────┼────────────────────────────┤
│  8 │                 0.209259   │                 0.209259   │
├────┼────────────────────────────┼────────────────────────────┤
│  9 │               nan          │                 0.599907   │
╘════╧════════════════════════════╧════════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_aw_winter_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_aw_winter_total_dose&gt;<br/><br/>    def test_aw_winter_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.aw_winter_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;aw_winter_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:360: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([    nan,     nan, 0.00079,     nan,     nan, 0.0763 , 0.03852,</span><br/><span class="error">E                      nan, 0.113  ,     nan])</span><br/><span class="error">E            y: array([8.352019e-03, 5.793040e-05, 7.898000e-04, 2.114200e+01,</span><br/><span class="error">E                  2.782757e-01, 7.630000e-02, 3.852000e-02, 1.265306e-02,</span><br/><span class="error">E                  1.130000e-01, 3.239500e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════════════╤════════════════════════════╕
│    │   out_aw_winter_total_dose │   exp_aw_winter_total_dose │
╞════╪════════════════════════════╪════════════════════════════╡
│  0 │                nan         │                0.00835202  │
├────┼────────────────────────────┼────────────────────────────┤
│  1 │                nan         │                5.79304e-05 │
├────┼────────────────────────────┼────────────────────────────┤
│  2 │                  0.0007898 │                0.0007898   │
├────┼────────────────────────────┼────────────────────────────┤
│  3 │                nan         │               21.142       │
├────┼────────────────────────────┼────────────────────────────┤
│  4 │                nan         │                0.278276    │
├────┼────────────────────────────┼────────────────────────────┤
│  5 │                  0.0763    │                0.0763      │
├────┼────────────────────────────┼────────────────────────────┤
│  6 │                  0.03852   │                0.03852     │
├────┼────────────────────────────┼────────────────────────────┤
│  7 │                nan         │                0.0126531   │
├────┼────────────────────────────┼────────────────────────────┤
│  8 │                  0.113     │                0.113       │
├────┼────────────────────────────┼────────────────────────────┤
│  9 │                nan         │                3.2395      │
╘════╧════════════════════════════╧════════════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_eec_method</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 100.0%)</span><br/><span class="error">E                x: array([ True,  True,  True,  True,  True,  True,  True,  True,  True,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_eec_method&gt;<br/><br/>    def test_eec_method(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.eec_method<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;eec&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:200: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([nan, nan, nan, nan, nan, nan, nan, nan, nan, nan])</span><br/><span class="error">E            y: array([2.694200e-04, 1.868720e-06, 9.902771e-03, 6.820000e-01,</span><br/><span class="error">E                  8.976636e-03, 1.000000e-03, 1.595000e+00, 4.081630e-04,</span><br/><span class="error">E                  9.576167e-03, 1.045000e-01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═══════════╤═════════════╕
│    │   out_eec │     exp_eec │
╞════╪═══════════╪═════════════╡
│  0 │       nan │ 0.00026942  │
├────┼───────────┼─────────────┤
│  1 │       nan │ 1.86872e-06 │
├────┼───────────┼─────────────┤
│  2 │       nan │ 0.00990277  │
├────┼───────────┼─────────────┤
│  3 │       nan │ 0.682       │
├────┼───────────┼─────────────┤
│  4 │       nan │ 0.00897664  │
├────┼───────────┼─────────────┤
│  5 │       nan │ 0.001       │
├────┼───────────┼─────────────┤
│  6 │       nan │ 1.595       │
├────┼───────────┼─────────────┤
│  7 │       nan │ 0.000408163 │
├────┼───────────┼─────────────┤
│  8 │       nan │ 0.00957617  │
├────┼───────────┼─────────────┤
│  9 │       nan │ 0.1045      │
╘════╧═══════════╧═════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_eec_seed</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([ True,  True,  True,  True,  True, False,  True,  True,  True,<br/>        True])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([ True,  True,  True,  True,  True, False,  True,  True,  True,<br/>        True])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([ True,  True,  True,  True,  True, False,  True,  True,  True,<br/>        True])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 10.0%)</span><br/><span class="error">E                x: array([ True,  True,  True,  True,  True,  True,  True,  True,  True,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([ True,  True,  True,  True,  True, False,  True,  True,  True,</span><br/><span class="error">E                       True])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_eec_seed&gt;<br/><br/>    def test_eec_seed(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.eec_seed<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;eec_seed&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:180: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([ True,  True,  True,  True,  True, False,  True,  True,  True,<br/>        True])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([nan, nan, nan, nan, nan, nan, nan, nan, nan, nan])</span><br/><span class="error">E            y: array([  nan,   nan,   nan,   nan,   nan, 0.001,   nan,   nan,   nan,</span><br/><span class="error">E                    nan])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════╤════════════════╕
│    │   out_eec_seed │   exp_eec_seed │
╞════╪════════════════╪════════════════╡
│  0 │            nan │        nan     │
├────┼────────────────┼────────────────┤
│  1 │            nan │        nan     │
├────┼────────────────┼────────────────┤
│  2 │            nan │        nan     │
├────┼────────────────┼────────────────┤
│  3 │            nan │        nan     │
├────┼────────────────┼────────────────┤
│  4 │            nan │        nan     │
├────┼────────────────┼────────────────┤
│  5 │            nan │          0.001 │
├────┼────────────────┼────────────────┤
│  6 │            nan │        nan     │
├────┼────────────────┼────────────────┤
│  7 │            nan │        nan     │
├────┼────────────────┼────────────────┤
│  8 │            nan │        nan     │
├────┼────────────────┼────────────────┤
│  9 │            nan │        nan     │
╘════╧════════════════╧════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_eec_soil</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([False,  True, False,  True, False,  True,  True,  True, False,<br/>        True])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([False,  True, False,  True, False,  True,  True,  True, False,<br/>        True])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([False,  True, False,  True, False,  True,  True,  True, False,<br/>        True])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 40.0%)</span><br/><span class="error">E                x: array([ True,  True,  True,  True,  True,  True,  True,  True,  True,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False,  True, False,  True, False,  True,  True,  True, False,</span><br/><span class="error">E                       True])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_eec_soil&gt;<br/><br/>    def test_eec_soil(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.eec_soil<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;eec_soil&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:170: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([False,  True, False,  True, False,  True,  True,  True, False,<br/>        True])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([nan, nan, nan, nan, nan, nan, nan, nan, nan, nan])</span><br/><span class="error">E            y: array([0.000269,      nan, 0.009903,      nan, 0.008977,      nan,</span><br/><span class="error">E                       nan,      nan, 0.009576,      nan])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════╤════════════════╕
│    │   out_eec_soil │   exp_eec_soil │
╞════╪════════════════╪════════════════╡
│  0 │            nan │     0.00026942 │
├────┼────────────────┼────────────────┤
│  1 │            nan │   nan          │
├────┼────────────────┼────────────────┤
│  2 │            nan │     0.00990277 │
├────┼────────────────┼────────────────┤
│  3 │            nan │   nan          │
├────┼────────────────┼────────────────┤
│  4 │            nan │     0.00897664 │
├────┼────────────────┼────────────────┤
│  5 │            nan │   nan          │
├────┼────────────────┼────────────────┤
│  6 │            nan │   nan          │
├────┼────────────────┼────────────────┤
│  7 │            nan │   nan          │
├────┼────────────────┼────────────────┤
│  8 │            nan │     0.00957617 │
├────┼────────────────┼────────────────┤
│  9 │            nan │   nan          │
╘════╧════════════════╧════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_eec_spray</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([ True,  True,  True, False,  True,  True, False,  True,  True,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([ True,  True,  True, False,  True,  True, False,  True,  True,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([ True,  True,  True, False,  True,  True, False,  True,  True,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 30.0%)</span><br/><span class="error">E                x: array([ True,  True,  True,  True,  True,  True,  True,  True,  True,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([ True,  True,  True, False,  True,  True, False,  True,  True,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_eec_spray&gt;<br/><br/>    def test_eec_spray(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.eec_spray<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;eec_spray&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:160: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([ True,  True,  True, False,  True,  True, False,  True,  True,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([nan, nan, nan, nan, nan, nan, nan, nan, nan, nan])</span><br/><span class="error">E            y: array([   nan,    nan,    nan, 0.682 ,    nan,    nan, 1.595 ,    nan,</span><br/><span class="error">E                     nan, 0.1045])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤═════════════════╤═════════════════╕
│    │   out_eec_spray │   exp_eec_spray │
╞════╪═════════════════╪═════════════════╡
│  0 │             nan │        nan      │
├────┼─────────────────┼─────────────────┤
│  1 │             nan │        nan      │
├────┼─────────────────┼─────────────────┤
│  2 │             nan │        nan      │
├────┼─────────────────┼─────────────────┤
│  3 │             nan │          0.682  │
├────┼─────────────────┼─────────────────┤
│  4 │             nan │        nan      │
├────┼─────────────────┼─────────────────┤
│  5 │             nan │        nan      │
├────┼─────────────────┼─────────────────┤
│  6 │             nan │          1.595  │
├────┼─────────────────┼─────────────────┤
│  7 │             nan │        nan      │
├────┼─────────────────┼─────────────────┤
│  8 │             nan │        nan      │
├────┼─────────────────┼─────────────────┤
│  9 │             nan │          0.1045 │
╘════╧═════════════════╧═════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_eec_tree</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([ True, False,  True,  True,  True,  True,  True, False,  True,<br/>        True])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([ True, False,  True,  True,  True,  True,  True, False,  True,<br/>        True])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y = array([ True, False,  True,  True,  True,  True,  True, False,  True,<br/>        True])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 20.0%)</span><br/><span class="error">E                x: array([ True,  True,  True,  True,  True,  True,  True,  True,  True,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([ True, False,  True,  True,  True,  True,  True, False,  True,</span><br/><span class="error">E                       True])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_eec_tree&gt;<br/><br/>    def test_eec_tree(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.eec_tree<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;eec_tree&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:190: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True,  True,  True,  True,  True,  True,  True,  True,<br/>        True])<br/>y_id = array([ True, False,  True,  True,  True,  True,  True, False,  True,<br/>        True])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([nan, nan, nan, nan, nan, nan, nan, nan, nan, nan])</span><br/><span class="error">E            y: array([        nan, 1.86872e-06,         nan,         nan,         nan,</span><br/><span class="error">E                          nan,         nan, 4.08163e-04,         nan,         nan])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════╤════════════════╕
│    │   out_eec_tree │   exp_eec_tree │
╞════╪════════════════╪════════════════╡
│  0 │            nan │  nan           │
├────┼────────────────┼────────────────┤
│  1 │            nan │    1.86872e-06 │
├────┼────────────────┼────────────────┤
│  2 │            nan │  nan           │
├────┼────────────────┼────────────────┤
│  3 │            nan │  nan           │
├────┼────────────────┼────────────────┤
│  4 │            nan │  nan           │
├────┼────────────────┼────────────────┤
│  5 │            nan │  nan           │
├────┼────────────────┼────────────────┤
│  6 │            nan │  nan           │
├────┼────────────────┼────────────────┤
│  7 │            nan │    0.000408163 │
├────┼────────────────┼────────────────┤
│  8 │            nan │  nan           │
├────┼────────────────┼────────────────┤
│  9 │            nan │  nan           │
╘════╧════════════════╧════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_ld6_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_ld6_acute_rq&gt;<br/><br/>    def test_ld6_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.ld6_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;ld6_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:440: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.003631,      nan,      nan, 0.273161,</span><br/><span class="error">E                  0.146596,      nan, 0.118819,      nan])</span><br/><span class="error">E            y: array([7.198902e+00, 1.468596e-03, 3.631175e-03, 5.061956e+02,</span><br/><span class="error">E                  2.351527e-01, 2.731613e-01, 1.465957e-01, 2.870032e-01,</span><br/><span class="error">E                  1.188190e-01, 2.053118e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_ld6_acute_rq │   exp_ld6_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │       nan          │         7.1989     │
├────┼────────────────────┼────────────────────┤
│  1 │       nan          │         0.0014686  │
├────┼────────────────────┼────────────────────┤
│  2 │         0.00363118 │         0.00363117 │
├────┼────────────────────┼────────────────────┤
│  3 │       nan          │       506.196      │
├────┼────────────────────┼────────────────────┤
│  4 │       nan          │         0.235153   │
├────┼────────────────────┼────────────────────┤
│  5 │         0.273161   │         0.273161   │
├────┼────────────────────┼────────────────────┤
│  6 │         0.146596   │         0.146596   │
├────┼────────────────────┼────────────────────┤
│  7 │       nan          │         0.287003   │
├────┼────────────────────┼────────────────────┤
│  8 │         0.118819   │         0.118819   │
├────┼────────────────────┼────────────────────┤
│  9 │       nan          │         2.05312    │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_ld6_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_ld6_chronic_rq&gt;<br/><br/>    def test_ld6_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.ld6_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;ld6_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:613: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.007657,      nan,      nan, 0.470444,</span><br/><span class="error">E                  0.022967,      nan, 0.453673,      nan])</span><br/><span class="error">E            y: array([1.999695e+01, 1.248306e-02, 7.657043e-03, 1.627057e+01,</span><br/><span class="error">E                  1.934320e-01, 4.704444e-01, 2.296667e-02, 1.652443e-01,</span><br/><span class="error">E                  4.536727e-01, 1.439299e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_ld6_chronic_rq │   exp_ld6_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │         nan          │          19.9969     │
├────┼──────────────────────┼──────────────────────┤
│  1 │         nan          │           0.0124831  │
├────┼──────────────────────┼──────────────────────┤
│  2 │           0.00765704 │           0.00765704 │
├────┼──────────────────────┼──────────────────────┤
│  3 │         nan          │          16.2706     │
├────┼──────────────────────┼──────────────────────┤
│  4 │         nan          │           0.193432   │
├────┼──────────────────────┼──────────────────────┤
│  5 │           0.470444   │           0.470444   │
├────┼──────────────────────┼──────────────────────┤
│  6 │           0.0229667  │           0.0229667  │
├────┼──────────────────────┼──────────────────────┤
│  7 │         nan          │           0.165244   │
├────┼──────────────────────┼──────────────────────┤
│  8 │           0.453673   │           0.453673   │
├────┼──────────────────────┼──────────────────────┤
│  9 │         nan          │           1.4393     │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_ld6_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_ld6_total_dose&gt;<br/><br/>    def test_ld6_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.ld6_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;ld6_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:260: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.003522,      nan,      nan, 0.25404 ,</span><br/><span class="error">E                  0.1378  ,      nan, 0.49904 ,      nan])</span><br/><span class="error">E            y: array([3.599451e-02, 2.496610e-04, 3.522240e-03, 9.111520e+01,</span><br/><span class="error">E                  1.199279e+00, 2.540400e-01, 1.378000e-01, 5.453061e-02,</span><br/><span class="error">E                  4.990400e-01, 1.396120e+01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_ld6_total_dose │   exp_ld6_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │         nan          │          0.0359945   │
├────┼──────────────────────┼──────────────────────┤
│  1 │         nan          │          0.000249661 │
├────┼──────────────────────┼──────────────────────┤
│  2 │           0.00352224 │          0.00352224  │
├────┼──────────────────────┼──────────────────────┤
│  3 │         nan          │         91.1152      │
├────┼──────────────────────┼──────────────────────┤
│  4 │         nan          │          1.19928     │
├────┼──────────────────────┼──────────────────────┤
│  5 │           0.25404    │          0.25404     │
├────┼──────────────────────┼──────────────────────┤
│  6 │           0.1378     │          0.1378      │
├────┼──────────────────────┼──────────────────────┤
│  7 │         nan          │          0.0545306   │
├────┼──────────────────────┼──────────────────────┤
│  8 │           0.49904    │          0.49904     │
├────┼──────────────────────┼──────────────────────┤
│  9 │         nan          │         13.9612      │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq1_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq1_acute_rq&gt;<br/><br/>    def test_lq1_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq1_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq1_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:450: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 1.175258e-06,          nan,</span><br/><span class="error">E                           nan, 3.881720e-03, 2.870213e-03,          nan,</span><br/><span class="error">E                  3.528571e-04,          nan])</span><br/><span class="error">E            y: array([1.023796e-03, 2.088570e-07, 1.175260e-06, 7.198889e-02,</span><br/><span class="error">E                  3.344240e-05, 3.881720e-03, 2.870213e-03, 4.081630e-05,</span><br/><span class="error">E                  3.528570e-04, 2.919850e-04])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_lq1_acute_rq │   exp_lq1_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │      nan           │        0.0010238   │
├────┼────────────────────┼────────────────────┤
│  1 │      nan           │        2.08857e-07 │
├────┼────────────────────┼────────────────────┤
│  2 │        1.17526e-06 │        1.17526e-06 │
├────┼────────────────────┼────────────────────┤
│  3 │      nan           │        0.0719889   │
├────┼────────────────────┼────────────────────┤
│  4 │      nan           │        3.34424e-05 │
├────┼────────────────────┼────────────────────┤
│  5 │        0.00388172  │        0.00388172  │
├────┼────────────────────┼────────────────────┤
│  6 │        0.00287021  │        0.00287021  │
├────┼────────────────────┼────────────────────┤
│  7 │      nan           │        4.08163e-05 │
├────┼────────────────────┼────────────────────┤
│  8 │        0.000352857 │        0.000352857 │
├────┼────────────────────┼────────────────────┤
│  9 │      nan           │        0.000291985 │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq1_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq1_chronic_rq&gt;<br/><br/>    def test_lq1_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq1_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq1_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:623: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 2.478261e-06,          nan,</span><br/><span class="error">E                           nan, 6.685185e-03, 4.496667e-04,          nan,</span><br/><span class="error">E                  1.347273e-03,          nan])</span><br/><span class="error">E            y: array([2.843877e-03, 1.775290e-06, 2.478260e-06, 2.313929e-03,</span><br/><span class="error">E                  2.750900e-05, 6.685185e-03, 4.496670e-04, 2.350030e-05,</span><br/><span class="error">E                  1.347273e-03, 2.046910e-04])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lq1_chronic_rq │   exp_lq1_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │        nan           │          0.00284388  │
├────┼──────────────────────┼──────────────────────┤
│  1 │        nan           │          1.77529e-06 │
├────┼──────────────────────┼──────────────────────┤
│  2 │          2.47826e-06 │          2.47826e-06 │
├────┼──────────────────────┼──────────────────────┤
│  3 │        nan           │          0.00231393  │
├────┼──────────────────────┼──────────────────────┤
│  4 │        nan           │          2.7509e-05  │
├────┼──────────────────────┼──────────────────────┤
│  5 │          0.00668519  │          0.00668518  │
├────┼──────────────────────┼──────────────────────┤
│  6 │          0.000449667 │          0.000449667 │
├────┼──────────────────────┼──────────────────────┤
│  7 │        nan           │          2.35003e-05 │
├────┼──────────────────────┼──────────────────────┤
│  8 │          0.00134727  │          0.00134727  │
├────┼──────────────────────┼──────────────────────┤
│  9 │        nan           │          0.000204691 │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq1_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq1_total_dose&gt;<br/><br/>    def test_lq1_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq1_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq1_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:270: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([      nan,       nan, 1.140e-06,       nan,       nan, 3.610e-03,</span><br/><span class="error">E                  2.698e-03,       nan, 1.482e-03,       nan])</span><br/><span class="error">E            y: array([5.11898e-06, 3.55057e-08, 1.14000e-06, 1.29580e-02, 1.70556e-04,</span><br/><span class="error">E                  3.61000e-03, 2.69800e-03, 7.75510e-06, 1.48200e-03, 1.98550e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lq1_total_dose │   exp_lq1_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │           nan        │          5.11898e-06 │
├────┼──────────────────────┼──────────────────────┤
│  1 │           nan        │          3.55057e-08 │
├────┼──────────────────────┼──────────────────────┤
│  2 │             1.14e-06 │          1.14e-06    │
├────┼──────────────────────┼──────────────────────┤
│  3 │           nan        │          0.012958    │
├────┼──────────────────────┼──────────────────────┤
│  4 │           nan        │          0.000170556 │
├────┼──────────────────────┼──────────────────────┤
│  5 │             0.00361  │          0.00361     │
├────┼──────────────────────┼──────────────────────┤
│  6 │             0.002698 │          0.002698    │
├────┼──────────────────────┼──────────────────────┤
│  7 │           nan        │          7.7551e-06  │
├────┼──────────────────────┼──────────────────────┤
│  8 │             0.001482 │          0.001482    │
├────┼──────────────────────┼──────────────────────┤
│  9 │           nan        │          0.0019855   │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq2_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq2_acute_rq&gt;<br/><br/>    def test_lq2_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq2_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq2_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:460: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 5.814433e-06,          nan,</span><br/><span class="error">E                           nan, 1.920430e-02, 1.420000e-02,          nan,</span><br/><span class="error">E                  1.745714e-03,          nan])</span><br/><span class="error">E            y: array([5.065095e-03, 1.033290e-06, 5.814430e-06, 3.561556e-01,</span><br/><span class="error">E                  1.654520e-04, 1.920430e-02, 1.420000e-02, 2.019330e-04,</span><br/><span class="error">E                  1.745714e-03, 1.444559e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_lq2_acute_rq │   exp_lq2_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │      nan           │        0.0050651   │
├────┼────────────────────┼────────────────────┤
│  1 │      nan           │        1.03329e-06 │
├────┼────────────────────┼────────────────────┤
│  2 │        5.81443e-06 │        5.81443e-06 │
├────┼────────────────────┼────────────────────┤
│  3 │      nan           │        0.356156    │
├────┼────────────────────┼────────────────────┤
│  4 │      nan           │        0.000165452 │
├────┼────────────────────┼────────────────────┤
│  5 │        0.0192043   │        0.0192043   │
├────┼────────────────────┼────────────────────┤
│  6 │        0.0142      │        0.0142      │
├────┼────────────────────┼────────────────────┤
│  7 │      nan           │        0.000201933 │
├────┼────────────────────┼────────────────────┤
│  8 │        0.00174571  │        0.00174571  │
├────┼────────────────────┼────────────────────┤
│  9 │      nan           │        0.00144456  │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq2_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq2_chronic_rq&gt;<br/><br/>    def test_lq2_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq2_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq2_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:633: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 1.226087e-05,          nan,</span><br/><span class="error">E                           nan, 3.307407e-02, 2.224667e-03,          nan,</span><br/><span class="error">E                  6.665455e-03,          nan])</span><br/><span class="error">E            y: array([1.406971e-02, 8.782990e-06, 1.226090e-05, 1.144786e-02,</span><br/><span class="error">E                  1.360970e-04, 3.307407e-02, 2.224667e-03, 1.162650e-04,</span><br/><span class="error">E                  6.665455e-03, 1.012680e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lq2_chronic_rq │   exp_lq2_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │        nan           │          0.0140697   │
├────┼──────────────────────┼──────────────────────┤
│  1 │        nan           │          8.78299e-06 │
├────┼──────────────────────┼──────────────────────┤
│  2 │          1.22609e-05 │          1.22609e-05 │
├────┼──────────────────────┼──────────────────────┤
│  3 │        nan           │          0.0114479   │
├────┼──────────────────────┼──────────────────────┤
│  4 │        nan           │          0.000136097 │
├────┼──────────────────────┼──────────────────────┤
│  5 │          0.0330741   │          0.0330741   │
├────┼──────────────────────┼──────────────────────┤
│  6 │          0.00222467  │          0.00222467  │
├────┼──────────────────────┼──────────────────────┤
│  7 │        nan           │          0.000116265 │
├────┼──────────────────────┼──────────────────────┤
│  8 │          0.00666545  │          0.00666545  │
├────┼──────────────────────┼──────────────────────┤
│  9 │        nan           │          0.00101268  │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq2_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq2_total_dose&gt;<br/><br/>    def test_lq2_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq2_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq2_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:280: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([       nan,        nan, 5.6400e-06,        nan,        nan,</span><br/><span class="error">E                  1.7860e-02, 1.3348e-02,        nan, 7.3320e-03,        nan])</span><br/><span class="error">E            y: array([2.53255e-05, 1.75660e-07, 5.64000e-06, 6.41080e-02, 8.43804e-04,</span><br/><span class="error">E                  1.78600e-02, 1.33480e-02, 3.83673e-05, 7.33200e-03, 9.82300e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lq2_total_dose │   exp_lq2_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │           nan        │          2.53255e-05 │
├────┼──────────────────────┼──────────────────────┤
│  1 │           nan        │          1.7566e-07  │
├────┼──────────────────────┼──────────────────────┤
│  2 │             5.64e-06 │          5.64e-06    │
├────┼──────────────────────┼──────────────────────┤
│  3 │           nan        │          0.064108    │
├────┼──────────────────────┼──────────────────────┤
│  4 │           nan        │          0.000843804 │
├────┼──────────────────────┼──────────────────────┤
│  5 │             0.01786  │          0.01786     │
├────┼──────────────────────┼──────────────────────┤
│  6 │             0.013348 │          0.013348    │
├────┼──────────────────────┼──────────────────────┤
│  7 │           nan        │          3.83673e-05 │
├────┼──────────────────────┼──────────────────────┤
│  8 │             0.007332 │          0.007332    │
├────┼──────────────────────┼──────────────────────┤
│  9 │           nan        │          0.009823    │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq3_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq3_acute_rq&gt;<br/><br/>    def test_lq3_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq3_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq3_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:471: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 1.422680e-05,          nan,</span><br/><span class="error">E                           nan, 4.698925e-02, 3.474468e-02,          nan,</span><br/><span class="error">E                  4.271429e-03,          nan])</span><br/><span class="error">E            y: array([1.239332e-02, 2.528270e-06, 1.422680e-05, 8.714444e-01,</span><br/><span class="error">E                  4.048290e-04, 4.698925e-02, 3.474468e-02, 4.940920e-04,</span><br/><span class="error">E                  4.271429e-03, 3.534559e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_lq3_acute_rq │   exp_lq3_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │      nan           │        0.0123933   │
├────┼────────────────────┼────────────────────┤
│  1 │      nan           │        2.52827e-06 │
├────┼────────────────────┼────────────────────┤
│  2 │        1.42268e-05 │        1.42268e-05 │
├────┼────────────────────┼────────────────────┤
│  3 │      nan           │        0.871444    │
├────┼────────────────────┼────────────────────┤
│  4 │      nan           │        0.000404829 │
├────┼────────────────────┼────────────────────┤
│  5 │        0.0469892   │        0.0469892   │
├────┼────────────────────┼────────────────────┤
│  6 │        0.0347447   │        0.0347447   │
├────┼────────────────────┼────────────────────┤
│  7 │      nan           │        0.000494092 │
├────┼────────────────────┼────────────────────┤
│  8 │        0.00427143  │        0.00427143  │
├────┼────────────────────┼────────────────────┤
│  9 │      nan           │        0.00353456  │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq3_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq3_chronic_rq&gt;<br/><br/>    def test_lq3_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq3_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq3_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:643: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 3.000000e-05,          nan,</span><br/><span class="error">E                           nan, 8.092593e-02, 5.443333e-03,          nan,</span><br/><span class="error">E                  1.630909e-02,          nan])</span><br/><span class="error">E            y: array([3.442589e-02, 2.149030e-05, 3.000000e-05, 2.801071e-02,</span><br/><span class="error">E                  3.330040e-04, 8.092593e-02, 5.443333e-03, 2.844770e-04,</span><br/><span class="error">E                  1.630909e-02, 2.477835e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lq3_chronic_rq │   exp_lq3_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │         nan          │          0.0344259   │
├────┼──────────────────────┼──────────────────────┤
│  1 │         nan          │          2.14903e-05 │
├────┼──────────────────────┼──────────────────────┤
│  2 │           3e-05      │          3e-05       │
├────┼──────────────────────┼──────────────────────┤
│  3 │         nan          │          0.0280107   │
├────┼──────────────────────┼──────────────────────┤
│  4 │         nan          │          0.000333004 │
├────┼──────────────────────┼──────────────────────┤
│  5 │           0.0809259  │          0.0809259   │
├────┼──────────────────────┼──────────────────────┤
│  6 │           0.00544333 │          0.00544333  │
├────┼──────────────────────┼──────────────────────┤
│  7 │         nan          │          0.000284477 │
├────┼──────────────────────┼──────────────────────┤
│  8 │           0.0163091  │          0.0163091   │
├────┼──────────────────────┼──────────────────────┤
│  9 │         nan          │          0.00247783  │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq3_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq3_total_dose&gt;<br/><br/>    def test_lq3_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq3_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq3_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:290: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([      nan,       nan, 1.380e-05,       nan,       nan, 4.370e-02,</span><br/><span class="error">E                  3.266e-02,       nan, 1.794e-02,       nan])</span><br/><span class="error">E            y: array([6.196660e-05, 4.298100e-07, 1.380000e-05, 1.568600e-01,</span><br/><span class="error">E                  2.064626e-03, 4.370000e-02, 3.266000e-02, 9.387760e-05,</span><br/><span class="error">E                  1.794000e-02, 2.403500e-02])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lq3_total_dose │   exp_lq3_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │           nan        │          6.19666e-05 │
├────┼──────────────────────┼──────────────────────┤
│  1 │           nan        │          4.2981e-07  │
├────┼──────────────────────┼──────────────────────┤
│  2 │             1.38e-05 │          1.38e-05    │
├────┼──────────────────────┼──────────────────────┤
│  3 │           nan        │          0.15686     │
├────┼──────────────────────┼──────────────────────┤
│  4 │           nan        │          0.00206463  │
├────┼──────────────────────┼──────────────────────┤
│  5 │             0.0437   │          0.0437      │
├────┼──────────────────────┼──────────────────────┤
│  6 │             0.03266  │          0.03266     │
├────┼──────────────────────┼──────────────────────┤
│  7 │           nan        │          9.38776e-05 │
├────┼──────────────────────┼──────────────────────┤
│  8 │             0.01794  │          0.01794     │
├────┼──────────────────────┼──────────────────────┤
│  9 │           nan        │          0.024035    │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq4_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq4_acute_rq&gt;<br/><br/>    def test_lq4_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq4_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq4_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:481: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 8.721649e-05,          nan,</span><br/><span class="error">E                           nan, 2.880645e-01, 2.130000e-01,          nan,</span><br/><span class="error">E                  2.618571e-02,          nan])</span><br/><span class="error">E            y: array([7.597643e-02, 1.549940e-05, 8.721650e-05, 5.342333e+00,</span><br/><span class="error">E                  2.481776e-03, 2.880645e-01, 2.130000e-01, 3.029001e-03,</span><br/><span class="error">E                  2.618571e-02, 2.166838e-02])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_lq4_acute_rq │   exp_lq4_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │      nan           │        0.0759764   │
├────┼────────────────────┼────────────────────┤
│  1 │      nan           │        1.54994e-05 │
├────┼────────────────────┼────────────────────┤
│  2 │        8.72165e-05 │        8.72165e-05 │
├────┼────────────────────┼────────────────────┤
│  3 │      nan           │        5.34233     │
├────┼────────────────────┼────────────────────┤
│  4 │      nan           │        0.00248178  │
├────┼────────────────────┼────────────────────┤
│  5 │        0.288065    │        0.288065    │
├────┼────────────────────┼────────────────────┤
│  6 │        0.213       │        0.213       │
├────┼────────────────────┼────────────────────┤
│  7 │      nan           │        0.003029    │
├────┼────────────────────┼────────────────────┤
│  8 │        0.0261857   │        0.0261857   │
├────┼────────────────────┼────────────────────┤
│  9 │      nan           │        0.0216684   │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq4_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq4_chronic_rq&gt;<br/><br/>    def test_lq4_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq4_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq4_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:653: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 1.839130e-04,          nan,</span><br/><span class="error">E                           nan, 4.961111e-01, 3.337000e-02,          nan,</span><br/><span class="error">E                  9.998182e-02,          nan])</span><br/><span class="error">E            y: array([2.110456e-01, 1.317450e-04, 1.839130e-04, 1.717179e-01,</span><br/><span class="error">E                  2.041461e-03, 4.961111e-01, 3.337000e-02, 1.743970e-03,</span><br/><span class="error">E                  9.998182e-02, 1.519021e-02])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lq4_chronic_rq │   exp_lq4_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │        nan           │          0.211046    │
├────┼──────────────────────┼──────────────────────┤
│  1 │        nan           │          0.000131745 │
├────┼──────────────────────┼──────────────────────┤
│  2 │          0.000183913 │          0.000183913 │
├────┼──────────────────────┼──────────────────────┤
│  3 │        nan           │          0.171718    │
├────┼──────────────────────┼──────────────────────┤
│  4 │        nan           │          0.00204146  │
├────┼──────────────────────┼──────────────────────┤
│  5 │          0.496111    │          0.496111    │
├────┼──────────────────────┼──────────────────────┤
│  6 │          0.03337     │          0.03337     │
├────┼──────────────────────┼──────────────────────┤
│  7 │        nan           │          0.00174397  │
├────┼──────────────────────┼──────────────────────┤
│  8 │          0.0999818   │          0.0999818   │
├────┼──────────────────────┼──────────────────────┤
│  9 │        nan           │          0.0151902   │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lq4_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lq4_total_dose&gt;<br/><br/>    def test_lq4_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lq4_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lq4_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:300: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([       nan,        nan, 8.4600e-05,        nan,        nan,</span><br/><span class="error">E                  2.6790e-01, 2.0022e-01,        nan, 1.0998e-01,        nan])</span><br/><span class="error">E            y: array([3.798820e-04, 2.634900e-06, 8.460000e-05, 9.616200e-01,</span><br/><span class="error">E                  1.265706e-02, 2.679000e-01, 2.002200e-01, 5.755100e-04,</span><br/><span class="error">E                  1.099800e-01, 1.473450e-01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lq4_total_dose │   exp_lq4_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │           nan        │          0.000379882 │
├────┼──────────────────────┼──────────────────────┤
│  1 │           nan        │          2.6349e-06  │
├────┼──────────────────────┼──────────────────────┤
│  2 │             8.46e-05 │          8.46e-05    │
├────┼──────────────────────┼──────────────────────┤
│  3 │           nan        │          0.96162     │
├────┼──────────────────────┼──────────────────────┤
│  4 │           nan        │          0.0126571   │
├────┼──────────────────────┼──────────────────────┤
│  5 │             0.2679   │          0.2679      │
├────┼──────────────────────┼──────────────────────┤
│  6 │             0.20022  │          0.20022     │
├────┼──────────────────────┼──────────────────────┤
│  7 │           nan        │          0.00057551  │
├────┼──────────────────────┼──────────────────────┤
│  8 │             0.10998  │          0.10998     │
├────┼──────────────────────┼──────────────────────┤
│  9 │           nan        │          0.147345    │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw1_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw1_acute_rq&gt;<br/><br/>    def test_lw1_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw1_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw1_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:390: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 1.175258e-06,          nan,</span><br/><span class="error">E                           nan, 3.881720e-03, 2.870213e-03,          nan,</span><br/><span class="error">E                  3.528571e-04,          nan])</span><br/><span class="error">E            y: array([1.023796e-03, 2.088570e-07, 1.175260e-06, 7.198889e-02,</span><br/><span class="error">E                  3.344240e-05, 3.881720e-03, 2.870213e-03, 4.081630e-05,</span><br/><span class="error">E                  3.528570e-04, 2.919850e-04])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_lw1_acute_rq │   exp_lw1_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │      nan           │        0.0010238   │
├────┼────────────────────┼────────────────────┤
│  1 │      nan           │        2.08857e-07 │
├────┼────────────────────┼────────────────────┤
│  2 │        1.17526e-06 │        1.17526e-06 │
├────┼────────────────────┼────────────────────┤
│  3 │      nan           │        0.0719889   │
├────┼────────────────────┼────────────────────┤
│  4 │      nan           │        3.34424e-05 │
├────┼────────────────────┼────────────────────┤
│  5 │        0.00388172  │        0.00388172  │
├────┼────────────────────┼────────────────────┤
│  6 │        0.00287021  │        0.00287021  │
├────┼────────────────────┼────────────────────┤
│  7 │      nan           │        4.08163e-05 │
├────┼────────────────────┼────────────────────┤
│  8 │        0.000352857 │        0.000352857 │
├────┼────────────────────┼────────────────────┤
│  9 │      nan           │        0.000291985 │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw1_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw1_chronic_rq&gt;<br/><br/>    def test_lw1_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw1_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw1_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:563: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 2.478261e-06,          nan,</span><br/><span class="error">E                           nan, 6.685185e-03, 4.496667e-04,          nan,</span><br/><span class="error">E                  1.347273e-03,          nan])</span><br/><span class="error">E            y: array([2.843877e-03, 1.775290e-06, 2.478260e-06, 2.313929e-03,</span><br/><span class="error">E                  2.750900e-05, 6.685185e-03, 4.496670e-04, 2.350030e-05,</span><br/><span class="error">E                  1.347273e-03, 2.046910e-04])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw1_chronic_rq │   exp_lw1_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │        nan           │          0.00284388  │
├────┼──────────────────────┼──────────────────────┤
│  1 │        nan           │          1.77529e-06 │
├────┼──────────────────────┼──────────────────────┤
│  2 │          2.47826e-06 │          2.47826e-06 │
├────┼──────────────────────┼──────────────────────┤
│  3 │        nan           │          0.00231393  │
├────┼──────────────────────┼──────────────────────┤
│  4 │        nan           │          2.7509e-05  │
├────┼──────────────────────┼──────────────────────┤
│  5 │          0.00668519  │          0.00668518  │
├────┼──────────────────────┼──────────────────────┤
│  6 │          0.000449667 │          0.000449667 │
├────┼──────────────────────┼──────────────────────┤
│  7 │        nan           │          2.35003e-05 │
├────┼──────────────────────┼──────────────────────┤
│  8 │          0.00134727  │          0.00134727  │
├────┼──────────────────────┼──────────────────────┤
│  9 │        nan           │          0.000204691 │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw1_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw1_total_dose&gt;<br/><br/>    def test_lw1_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw1_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw1_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:210: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([      nan,       nan, 1.140e-06,       nan,       nan, 3.610e-03,</span><br/><span class="error">E                  2.698e-03,       nan, 1.482e-03,       nan])</span><br/><span class="error">E            y: array([5.11898e-06, 3.55057e-08, 1.14000e-06, 1.29580e-02, 1.70556e-04,</span><br/><span class="error">E                  3.61000e-03, 2.69800e-03, 7.75510e-06, 1.48200e-03, 1.98550e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw1_total_dose │   exp_lw1_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │           nan        │          5.11898e-06 │
├────┼──────────────────────┼──────────────────────┤
│  1 │           nan        │          3.55057e-08 │
├────┼──────────────────────┼──────────────────────┤
│  2 │             1.14e-06 │          1.14e-06    │
├────┼──────────────────────┼──────────────────────┤
│  3 │           nan        │          0.012958    │
├────┼──────────────────────┼──────────────────────┤
│  4 │           nan        │          0.000170556 │
├────┼──────────────────────┼──────────────────────┤
│  5 │             0.00361  │          0.00361     │
├────┼──────────────────────┼──────────────────────┤
│  6 │             0.002698 │          0.002698    │
├────┼──────────────────────┼──────────────────────┤
│  7 │           nan        │          7.7551e-06  │
├────┼──────────────────────┼──────────────────────┤
│  8 │             0.001482 │          0.001482    │
├────┼──────────────────────┼──────────────────────┤
│  9 │           nan        │          0.0019855   │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw2_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw2_acute_rq&gt;<br/><br/>    def test_lw2_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw2_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw2_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:400: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 5.814433e-06,          nan,</span><br/><span class="error">E                           nan, 1.920430e-02, 1.420000e-02,          nan,</span><br/><span class="error">E                  1.745714e-03,          nan])</span><br/><span class="error">E            y: array([5.065095e-03, 1.033290e-06, 5.814430e-06, 3.561556e-01,</span><br/><span class="error">E                  1.654520e-04, 1.920430e-02, 1.420000e-02, 2.019330e-04,</span><br/><span class="error">E                  1.745714e-03, 1.444559e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_lw2_acute_rq │   exp_lw2_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │      nan           │        0.0050651   │
├────┼────────────────────┼────────────────────┤
│  1 │      nan           │        1.03329e-06 │
├────┼────────────────────┼────────────────────┤
│  2 │        5.81443e-06 │        5.81443e-06 │
├────┼────────────────────┼────────────────────┤
│  3 │      nan           │        0.356156    │
├────┼────────────────────┼────────────────────┤
│  4 │      nan           │        0.000165452 │
├────┼────────────────────┼────────────────────┤
│  5 │        0.0192043   │        0.0192043   │
├────┼────────────────────┼────────────────────┤
│  6 │        0.0142      │        0.0142      │
├────┼────────────────────┼────────────────────┤
│  7 │      nan           │        0.000201933 │
├────┼────────────────────┼────────────────────┤
│  8 │        0.00174571  │        0.00174571  │
├────┼────────────────────┼────────────────────┤
│  9 │      nan           │        0.00144456  │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw2_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw2_chronic_rq&gt;<br/><br/>    def test_lw2_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw2_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw2_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:573: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 1.226087e-05,          nan,</span><br/><span class="error">E                           nan, 3.307407e-02, 2.224667e-03,          nan,</span><br/><span class="error">E                  6.665455e-03,          nan])</span><br/><span class="error">E            y: array([1.406971e-02, 8.782990e-06, 1.226090e-05, 1.144786e-02,</span><br/><span class="error">E                  1.360970e-04, 3.307407e-02, 2.224667e-03, 1.162650e-04,</span><br/><span class="error">E                  6.665455e-03, 1.012680e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw2_chronic_rq │   exp_lw2_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │        nan           │          0.0140697   │
├────┼──────────────────────┼──────────────────────┤
│  1 │        nan           │          8.78299e-06 │
├────┼──────────────────────┼──────────────────────┤
│  2 │          1.22609e-05 │          1.22609e-05 │
├────┼──────────────────────┼──────────────────────┤
│  3 │        nan           │          0.0114479   │
├────┼──────────────────────┼──────────────────────┤
│  4 │        nan           │          0.000136097 │
├────┼──────────────────────┼──────────────────────┤
│  5 │          0.0330741   │          0.0330741   │
├────┼──────────────────────┼──────────────────────┤
│  6 │          0.00222467  │          0.00222467  │
├────┼──────────────────────┼──────────────────────┤
│  7 │        nan           │          0.000116265 │
├────┼──────────────────────┼──────────────────────┤
│  8 │          0.00666545  │          0.00666545  │
├────┼──────────────────────┼──────────────────────┤
│  9 │        nan           │          0.00101268  │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw2_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw2_total_dose&gt;<br/><br/>    def test_lw2_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw2_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw2_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:220: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([       nan,        nan, 5.6400e-06,        nan,        nan,</span><br/><span class="error">E                  1.7860e-02, 1.3348e-02,        nan, 7.3320e-03,        nan])</span><br/><span class="error">E            y: array([2.53255e-05, 1.75660e-07, 5.64000e-06, 6.41080e-02, 8.43804e-04,</span><br/><span class="error">E                  1.78600e-02, 1.33480e-02, 3.83673e-05, 7.33200e-03, 9.82300e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw2_total_dose │   exp_lw2_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │           nan        │          2.53255e-05 │
├────┼──────────────────────┼──────────────────────┤
│  1 │           nan        │          1.7566e-07  │
├────┼──────────────────────┼──────────────────────┤
│  2 │             5.64e-06 │          5.64e-06    │
├────┼──────────────────────┼──────────────────────┤
│  3 │           nan        │          0.064108    │
├────┼──────────────────────┼──────────────────────┤
│  4 │           nan        │          0.000843804 │
├────┼──────────────────────┼──────────────────────┤
│  5 │             0.01786  │          0.01786     │
├────┼──────────────────────┼──────────────────────┤
│  6 │             0.013348 │          0.013348    │
├────┼──────────────────────┼──────────────────────┤
│  7 │           nan        │          3.83673e-05 │
├────┼──────────────────────┼──────────────────────┤
│  8 │             0.007332 │          0.007332    │
├────┼──────────────────────┼──────────────────────┤
│  9 │           nan        │          0.009823    │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw3_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw3_acute_rq&gt;<br/><br/>    def test_lw3_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw3_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw3_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:410: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 1.175258e-05,          nan,</span><br/><span class="error">E                           nan, 3.881720e-02, 2.870213e-02,          nan,</span><br/><span class="error">E                  3.528571e-03,          nan])</span><br/><span class="error">E            y: array([1.023796e-02, 2.088570e-06, 1.175260e-05, 7.198889e-01,</span><br/><span class="error">E                  3.344240e-04, 3.881720e-02, 2.870213e-02, 4.081630e-04,</span><br/><span class="error">E                  3.528571e-03, 2.919853e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_lw3_acute_rq │   exp_lw3_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │      nan           │        0.010238    │
├────┼────────────────────┼────────────────────┤
│  1 │      nan           │        2.08857e-06 │
├────┼────────────────────┼────────────────────┤
│  2 │        1.17526e-05 │        1.17526e-05 │
├────┼────────────────────┼────────────────────┤
│  3 │      nan           │        0.719889    │
├────┼────────────────────┼────────────────────┤
│  4 │      nan           │        0.000334424 │
├────┼────────────────────┼────────────────────┤
│  5 │        0.0388172   │        0.0388172   │
├────┼────────────────────┼────────────────────┤
│  6 │        0.0287021   │        0.0287021   │
├────┼────────────────────┼────────────────────┤
│  7 │      nan           │        0.000408163 │
├────┼────────────────────┼────────────────────┤
│  8 │        0.00352857  │        0.00352857  │
├────┼────────────────────┼────────────────────┤
│  9 │      nan           │        0.00291985  │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw3_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw3_chronic_rq&gt;<br/><br/>    def test_lw3_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw3_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw3_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:583: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([         nan,          nan, 2.478261e-05,          nan,</span><br/><span class="error">E                           nan, 6.685185e-02, 4.496667e-03,          nan,</span><br/><span class="error">E                  1.347273e-02,          nan])</span><br/><span class="error">E            y: array([2.843877e-02, 1.775290e-05, 2.478260e-05, 2.313929e-02,</span><br/><span class="error">E                  2.750900e-04, 6.685185e-02, 4.496667e-03, 2.350030e-04,</span><br/><span class="error">E                  1.347273e-02, 2.046907e-03])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw3_chronic_rq │   exp_lw3_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │        nan           │          0.0284388   │
├────┼──────────────────────┼──────────────────────┤
│  1 │        nan           │          1.77529e-05 │
├────┼──────────────────────┼──────────────────────┤
│  2 │          2.47826e-05 │          2.47826e-05 │
├────┼──────────────────────┼──────────────────────┤
│  3 │        nan           │          0.0231393   │
├────┼──────────────────────┼──────────────────────┤
│  4 │        nan           │          0.00027509  │
├────┼──────────────────────┼──────────────────────┤
│  5 │          0.0668519   │          0.0668519   │
├────┼──────────────────────┼──────────────────────┤
│  6 │          0.00449667  │          0.00449667  │
├────┼──────────────────────┼──────────────────────┤
│  7 │        nan           │          0.000235003 │
├────┼──────────────────────┼──────────────────────┤
│  8 │          0.0134727   │          0.0134727   │
├────┼──────────────────────┼──────────────────────┤
│  9 │        nan           │          0.00204691  │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw3_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw3_total_dose&gt;<br/><br/>    def test_lw3_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw3_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw3_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:230: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([      nan,       nan, 1.140e-05,       nan,       nan, 3.610e-02,</span><br/><span class="error">E                  2.698e-02,       nan, 1.482e-02,       nan])</span><br/><span class="error">E            y: array([5.118980e-05, 3.550600e-07, 1.140000e-05, 1.295800e-01,</span><br/><span class="error">E                  1.705561e-03, 3.610000e-02, 2.698000e-02, 7.755100e-05,</span><br/><span class="error">E                  1.482000e-02, 1.985500e-02])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw3_total_dose │   exp_lw3_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │           nan        │          5.11898e-05 │
├────┼──────────────────────┼──────────────────────┤
│  1 │           nan        │          3.5506e-07  │
├────┼──────────────────────┼──────────────────────┤
│  2 │             1.14e-05 │          1.14e-05    │
├────┼──────────────────────┼──────────────────────┤
│  3 │           nan        │          0.12958     │
├────┼──────────────────────┼──────────────────────┤
│  4 │           nan        │          0.00170556  │
├────┼──────────────────────┼──────────────────────┤
│  5 │             0.0361   │          0.0361      │
├────┼──────────────────────┼──────────────────────┤
│  6 │             0.02698  │          0.02698     │
├────┼──────────────────────┼──────────────────────┤
│  7 │           nan        │          7.7551e-05  │
├────┼──────────────────────┼──────────────────────┤
│  8 │             0.01482  │          0.01482     │
├────┼──────────────────────┼──────────────────────┤
│  9 │           nan        │          0.019855    │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw4_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw4_acute_rq&gt;<br/><br/>    def test_lw4_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw4_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw4_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:420: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.001676,      nan,      nan, 0.128516,</span><br/><span class="error">E                  0.068617,      nan, 0.054886,      nan])</span><br/><span class="error">E            y: array([3.330031e+00, 6.793360e-04, 1.676412e-03, 2.341533e+02,</span><br/><span class="error">E                  1.087757e-01, 1.285161e-01, 6.861702e-02, 1.327605e-01,</span><br/><span class="error">E                  5.488571e-02, 9.497206e-01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_lw4_acute_rq │   exp_lw4_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │       nan          │        3.33003     │
├────┼────────────────────┼────────────────────┤
│  1 │       nan          │        0.000679336 │
├────┼────────────────────┼────────────────────┤
│  2 │         0.00167641 │        0.00167641  │
├────┼────────────────────┼────────────────────┤
│  3 │       nan          │      234.153       │
├────┼────────────────────┼────────────────────┤
│  4 │       nan          │        0.108776    │
├────┼────────────────────┼────────────────────┤
│  5 │         0.128516   │        0.128516    │
├────┼────────────────────┼────────────────────┤
│  6 │         0.068617   │        0.068617    │
├────┼────────────────────┼────────────────────┤
│  7 │       nan          │        0.13276     │
├────┼────────────────────┼────────────────────┤
│  8 │         0.0548857  │        0.0548857   │
├────┼────────────────────┼────────────────────┤
│  9 │       nan          │        0.949721    │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw4_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw4_chronic_rq&gt;<br/><br/>    def test_lw4_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw4_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw4_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:593: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.003535,      nan,      nan, 0.221333,</span><br/><span class="error">E                  0.01075 ,      nan, 0.209564,      nan])</span><br/><span class="error">E            y: array([9.250086e+00, 5.774352e-03, 3.535043e-03, 7.526357e+00,</span><br/><span class="error">E                  8.947679e-02, 2.213333e-01, 1.075000e-02, 7.643785e-02,</span><br/><span class="error">E                  2.095636e-01, 6.657835e-01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw4_chronic_rq │   exp_lw4_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │         nan          │           9.25009    │
├────┼──────────────────────┼──────────────────────┤
│  1 │         nan          │           0.00577435 │
├────┼──────────────────────┼──────────────────────┤
│  2 │           0.00353504 │           0.00353504 │
├────┼──────────────────────┼──────────────────────┤
│  3 │         nan          │           7.52636    │
├────┼──────────────────────┼──────────────────────┤
│  4 │         nan          │           0.0894768  │
├────┼──────────────────────┼──────────────────────┤
│  5 │           0.221333   │           0.221333   │
├────┼──────────────────────┼──────────────────────┤
│  6 │           0.01075    │           0.01075    │
├────┼──────────────────────┼──────────────────────┤
│  7 │         nan          │           0.0764378  │
├────┼──────────────────────┼──────────────────────┤
│  8 │           0.209564   │           0.209564   │
├────┼──────────────────────┼──────────────────────┤
│  9 │         nan          │           0.665784   │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw4_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw4_total_dose&gt;<br/><br/>    def test_lw4_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw4_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw4_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:240: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.001626,      nan,      nan, 0.11952 ,</span><br/><span class="error">E                  0.0645  ,      nan, 0.23052 ,      nan])</span><br/><span class="error">E            y: array([1.665015e-02, 1.154870e-04, 1.626120e-03, 4.214760e+01,</span><br/><span class="error">E                  5.547561e-01, 1.195200e-01, 6.450000e-02, 2.522449e-02,</span><br/><span class="error">E                  2.305200e-01, 6.458100e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw4_total_dose │   exp_lw4_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │         nan          │          0.0166502   │
├────┼──────────────────────┼──────────────────────┤
│  1 │         nan          │          0.000115487 │
├────┼──────────────────────┼──────────────────────┤
│  2 │           0.00162612 │          0.00162612  │
├────┼──────────────────────┼──────────────────────┤
│  3 │         nan          │         42.1476      │
├────┼──────────────────────┼──────────────────────┤
│  4 │         nan          │          0.554756    │
├────┼──────────────────────┼──────────────────────┤
│  5 │           0.11952    │          0.11952     │
├────┼──────────────────────┼──────────────────────┤
│  6 │           0.0645     │          0.0645      │
├────┼──────────────────────┼──────────────────────┤
│  7 │         nan          │          0.0252245   │
├────┼──────────────────────┼──────────────────────┤
│  8 │           0.23052    │          0.23052     │
├────┼──────────────────────┼──────────────────────┤
│  9 │         nan          │          6.4581      │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw5_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw5_acute_rq&gt;<br/><br/>    def test_lw5_acute_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw5_acute_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw5_acute_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:430: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.003353,      nan,      nan, 0.257032,</span><br/><span class="error">E                  0.137234,      nan, 0.109771,      nan])</span><br/><span class="error">E            y: array([6.660062e+00, 1.358671e-03, 3.352825e-03, 4.683067e+02,</span><br/><span class="error">E                  2.175514e-01, 2.570323e-01, 1.372340e-01, 2.655209e-01,</span><br/><span class="error">E                  1.097714e-01, 1.899441e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤════════════════════╤════════════════════╕
│    │   out_lw5_acute_rq │   exp_lw5_acute_rq │
╞════╪════════════════════╪════════════════════╡
│  0 │       nan          │         6.66006    │
├────┼────────────────────┼────────────────────┤
│  1 │       nan          │         0.00135867 │
├────┼────────────────────┼────────────────────┤
│  2 │         0.00335282 │         0.00335282 │
├────┼────────────────────┼────────────────────┤
│  3 │       nan          │       468.307      │
├────┼────────────────────┼────────────────────┤
│  4 │       nan          │         0.217551   │
├────┼────────────────────┼────────────────────┤
│  5 │         0.257032   │         0.257032   │
├────┼────────────────────┼────────────────────┤
│  6 │         0.137234   │         0.137234   │
├────┼────────────────────┼────────────────────┤
│  7 │       nan          │         0.265521   │
├────┼────────────────────┼────────────────────┤
│  8 │         0.109771   │         0.109771   │
├────┼────────────────────┼────────────────────┤
│  9 │       nan          │         1.89944    │
╘════╧════════════════════╧════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw5_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw5_chronic_rq&gt;<br/><br/>    def test_lw5_chronic_rq(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw5_chronic_rq<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw5_chronic_rq&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:603: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.00707 ,      nan,      nan, 0.442667,</span><br/><span class="error">E                  0.0215  ,      nan, 0.419127,      nan])</span><br/><span class="error">E            y: array([1.850017e+01, 1.154870e-02, 7.070087e-03, 1.505271e+01,</span><br/><span class="error">E                  1.789536e-01, 4.426667e-01, 2.150000e-02, 1.528757e-01,</span><br/><span class="error">E                  4.191273e-01, 1.331567e+00])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw5_chronic_rq │   exp_lw5_chronic_rq │
╞════╪══════════════════════╪══════════════════════╡
│  0 │         nan          │          18.5002     │
├────┼──────────────────────┼──────────────────────┤
│  1 │         nan          │           0.0115487  │
├────┼──────────────────────┼──────────────────────┤
│  2 │           0.00707009 │           0.00707009 │
├────┼──────────────────────┼──────────────────────┤
│  3 │         nan          │          15.0527     │
├────┼──────────────────────┼──────────────────────┤
│  4 │         nan          │           0.178954   │
├────┼──────────────────────┼──────────────────────┤
│  5 │           0.442667   │           0.442667   │
├────┼──────────────────────┼──────────────────────┤
│  6 │           0.0215     │           0.0215     │
├────┼──────────────────────┼──────────────────────┤
│  7 │         nan          │           0.152876   │
├────┼──────────────────────┼──────────────────────┤
│  8 │           0.419127   │           0.419127   │
├────┼──────────────────────┼──────────────────────┤
│  9 │         nan          │           1.33157    │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_lw5_total_dose</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>&gt;           assert_array_equal(x_id, y_id)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:700: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True<br/><br/>    def assert_array_equal(x, y, err_msg=&#x27;&#x27;, verbose=True):<br/>        &quot;&quot;&quot;<br/>        Raises an AssertionError if two array_like objects are not equal.<br/>    <br/>        Given two array_like objects, check that the shape is equal and all<br/>        elements of these objects are equal. An exception is raised at<br/>        shape mismatch or conflicting values. In contrast to the standard usage<br/>        in numpy, NaNs are compared like numbers, no assertion is raised if<br/>        both objects have NaNs in the same positions.<br/>    <br/>        The usual caution for verifying equality with floating point numbers is<br/>        advised.<br/>    <br/>        Parameters<br/>        ----------<br/>        x : array_like<br/>            The actual object to check.<br/>        y : array_like<br/>            The desired, expected object.<br/>        err_msg : str, optional<br/>            The error message to be printed in case of failure.<br/>        verbose : bool, optional<br/>            If True, the conflicting values are appended to the error message.<br/>    <br/>        Raises<br/>        ------<br/>        AssertionError<br/>            If actual and desired objects are not equal.<br/>    <br/>        See Also<br/>        --------<br/>        assert_allclose: Compare two array_like objects for equality with desired<br/>                         relative and/or absolute precision.<br/>        assert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal<br/>    <br/>        Examples<br/>        --------<br/>        The first assert does not raise an exception:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],<br/>        ...                               [np.exp(0),2.33333, np.nan])<br/>    <br/>        Assert fails with numerical inprecision with floats:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],<br/>        ...                               [1, np.sqrt(np.pi)**2, np.nan])<br/>        ...<br/>        &lt;type &#x27;exceptions.ValueError&#x27;&gt;:<br/>        AssertionError:<br/>        Arrays are not equal<br/>        &lt;BLANKLINE&gt;<br/>        (mismatch 50.0%)<br/>         x: array([ 1.        ,  3.14159265,         NaN])<br/>         y: array([ 1.        ,  3.14159265,         NaN])<br/>    <br/>        Use `assert_allclose` or one of the nulp (number of floating point values)<br/>        functions for these cases instead:<br/>    <br/>        &gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],<br/>        ...                            [1, np.sqrt(np.pi)**2, np.nan],<br/>        ...                            rtol=1e-10, atol=0)<br/>    <br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        assert_array_compare(operator.__eq__, x, y, err_msg=err_msg,<br/>&gt;                            verbose=verbose, header=&#x27;Arrays are not equal&#x27;)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:855: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>comparison = &lt;built-in function eq&gt;<br/>x = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>err_msg = &#x27;&#x27;, verbose = True, header = &#x27;Arrays are not equal&#x27;, precision = 6<br/>equal_nan = True, equal_inf = True<br/><br/>    def assert_array_compare(comparison, x, y, err_msg=&#x27;&#x27;, verbose=True,<br/>                             header=&#x27;&#x27;, precision=6, equal_nan=True,<br/>                             equal_inf=True):<br/>        __tracebackhide__ = True  # Hide traceback for py.test<br/>        from numpy.core import array, isnan, isinf, any, inf<br/>        x = array(x, copy=False, subok=True)<br/>        y = array(y, copy=False, subok=True)<br/>    <br/>        def isnumber(x):<br/>            return x.dtype.char in &#x27;?bhilqpBHILQPefdgFDG&#x27;<br/>    <br/>        def istime(x):<br/>            return x.dtype.char in &quot;Mm&quot;<br/>    <br/>        def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>            &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>            try:<br/>                assert_array_equal(x_id, y_id)<br/>            except AssertionError:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                    % (hasval), verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>        try:<br/>            cond = (x.shape == () or y.shape == ()) or x.shape == y.shape<br/>            if not cond:<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(shapes %s, %s mismatch)&#x27; % (x.shape,<br/>                                                                      y.shape),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>                raise AssertionError(msg)<br/>    <br/>            if isnumber(x) and isnumber(y):<br/>                has_nan = has_inf = False<br/>                if equal_nan:<br/>                    x_isnan, y_isnan = isnan(x), isnan(y)<br/>                    # Validate that NaNs are in the same place<br/>                    has_nan = any(x_isnan) or any(y_isnan)<br/>                    if has_nan:<br/>                        chk_same_position(x_isnan, y_isnan, hasval=&#x27;nan&#x27;)<br/>    <br/>                if equal_inf:<br/>                    x_isinf, y_isinf = isinf(x), isinf(y)<br/>                    # Validate that infinite values are in the same place<br/>                    has_inf = any(x_isinf) or any(y_isinf)<br/>                    if has_inf:<br/>                        # Check +inf and -inf separately, since they are different<br/>                        chk_same_position(x == +inf, y == +inf, hasval=&#x27;+inf&#x27;)<br/>                        chk_same_position(x == -inf, y == -inf, hasval=&#x27;-inf&#x27;)<br/>    <br/>                if has_nan and has_inf:<br/>                    x = x[~(x_isnan | x_isinf)]<br/>                    y = y[~(y_isnan | y_isinf)]<br/>                elif has_nan:<br/>                    x = x[~x_isnan]<br/>                    y = y[~y_isnan]<br/>                elif has_inf:<br/>                    x = x[~x_isinf]<br/>                    y = y[~y_isinf]<br/>    <br/>                # Only do the comparison if actual values are left<br/>                if x.size == 0:<br/>                    return<br/>    <br/>            elif istime(x) and istime(y):<br/>                # If one is datetime64 and the other timedelta64 there is no point<br/>                if equal_nan and x.dtype.type == y.dtype.type:<br/>                    x_isnat, y_isnat = isnat(x), isnat(y)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        chk_same_position(x_isnat, y_isnat, hasval=&quot;NaT&quot;)<br/>    <br/>                    if any(x_isnat) or any(y_isnat):<br/>                        x = x[~x_isnat]<br/>                        y = y[~y_isnat]<br/>    <br/>            val = comparison(x, y)<br/>    <br/>            if isinstance(val, bool):<br/>                cond = val<br/>                reduced = [0]<br/>            else:<br/>                reduced = val.ravel()<br/>                cond = reduced.all()<br/>                reduced = reduced.tolist()<br/>            if not cond:<br/>                match = 100-100.0*reduced.count(1)/len(reduced)<br/>                msg = build_err_msg([x, y],<br/>                                    err_msg<br/>                                    + &#x27;\n(mismatch %s%%)&#x27; % (match,),<br/>                                    verbose=verbose, header=header,<br/>                                    names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;               raise AssertionError(msg)<br/><span class="error">E               AssertionError: </span><br/><span class="error">E               Arrays are not equal</span><br/><span class="error">E               </span><br/><span class="error">E               (mismatch 60.0%)</span><br/><span class="error">E                x: array([ True,  True, False,  True,  True, False, False,  True, False,</span><br/><span class="error">E                       True])</span><br/><span class="error">E                y: array([False, False, False, False, False, False, False, False, False,</span><br/><span class="error">E                      False])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:779: AssertionError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_integration.TestBeerex testMethod=test_lw5_total_dose&gt;<br/><br/>    def test_lw5_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            Integration test for beerex.lw5_total_dose<br/>            &quot;&quot;&quot;<br/>        try:<br/>&gt;           self.blackbox_method_int(&#x27;lw5_total_dose&#x27;)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:250: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\tests\test_beerex_integration.py:744: in blackbox_method_int<br/>    npt.assert_allclose(result, expected, rtol, 0, True)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>x_id = array([ True,  True, False,  True,  True, False, False,  True, False,<br/>        True])<br/>y_id = array([False, False, False, False, False, False, False, False, False,<br/>       False])<br/>hasval = &#x27;nan&#x27;<br/><br/>    def chk_same_position(x_id, y_id, hasval=&#x27;nan&#x27;):<br/>        &quot;&quot;&quot;Handling nan/inf: check that x and y have the nan/inf at the same<br/>            locations.&quot;&quot;&quot;<br/>        try:<br/>            assert_array_equal(x_id, y_id)<br/>        except AssertionError:<br/>            msg = build_err_msg([x, y],<br/>                                err_msg + &#x27;\nx and y %s location mismatch:&#x27;<br/>                                % (hasval), verbose=verbose, header=header,<br/>                                names=(&#x27;x&#x27;, &#x27;y&#x27;), precision=precision)<br/>&gt;           raise AssertionError(msg)<br/><span class="error">E           AssertionError: </span><br/><span class="error">E           Not equal to tolerance rtol=1e-05, atol=0</span><br/><span class="error">E           </span><br/><span class="error">E           x and y nan location mismatch:</span><br/><span class="error">E            x: array([     nan,      nan, 0.003252,      nan,      nan, 0.23904 ,</span><br/><span class="error">E                  0.129   ,      nan, 0.46104 ,      nan])</span><br/><span class="error">E            y: array([3.330031e-02, 2.309740e-04, 3.252240e-03, 8.429520e+01,</span><br/><span class="error">E                  1.109512e+00, 2.390400e-01, 1.290000e-01, 5.044898e-02,</span><br/><span class="error">E                  4.610400e-01, 1.291620e+01])</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\numpy\testing\nose_tools\utils.py:706: AssertionError<br/>----------------------------- Captured stdout call -----------------------------<br/> 
╒════╤══════════════════════╤══════════════════════╕
│    │   out_lw5_total_dose │   exp_lw5_total_dose │
╞════╪══════════════════════╪══════════════════════╡
│  0 │         nan          │          0.0333003   │
├────┼──────────────────────┼──────────────────────┤
│  1 │         nan          │          0.000230974 │
├────┼──────────────────────┼──────────────────────┤
│  2 │           0.00325224 │          0.00325224  │
├────┼──────────────────────┼──────────────────────┤
│  3 │         nan          │         84.2952      │
├────┼──────────────────────┼──────────────────────┤
│  4 │         nan          │          1.10951     │
├────┼──────────────────────┼──────────────────────┤
│  5 │           0.23904    │          0.23904     │
├────┼──────────────────────┼──────────────────────┤
│  6 │           0.129      │          0.129       │
├────┼──────────────────────┼──────────────────────┤
│  7 │         nan          │          0.050449    │
├────┼──────────────────────┼──────────────────────┤
│  8 │           0.46104    │          0.46104     │
├────┼──────────────────────┼──────────────────────┤
│  9 │         nan          │         12.9162      │
╘════╧══════════════════════╧══════════════════════╛
</div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_ad_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = Series([], Name: out_eec_soil, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>&gt;           self.index._engine.set_value(values, key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:800: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:101: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:109: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>&gt;               return self._engine.get_loc(key)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>&gt;           self._set_with_engine(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:741: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_soil, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>            self.index._engine.set_value(values, key, value)<br/>            return<br/>        except KeyError:<br/>&gt;           values[self.index.get_loc(key)] = value<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:803: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>                return self._engine.get_loc(key)<br/>            except KeyError:<br/>&gt;               return self._engine.get_loc(self._maybe_cast_indexer(key))<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2527: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_ad_total_dose&gt;<br/><br/>    def test_beerex_ad_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.ad_total_dose<br/>            &quot;&quot;&quot;<br/>        #if self.empirical_residue[0] == True:<br/>        #    self.out_ad_total_dose = ((self.empirical_nectar/1000.) * self.ad_nectar) + ((self.empirical_pollen/1000.) * self.ad_pollen)<br/>        #else:<br/>        #    self.out_ad_total_dose = (self.out_eec_method * self.ad_nectar) + (self.out_eec_method * self.ad_pollen)<br/>    <br/>        try:<br/>            expected_results = [0.02904, 0.10844]<br/>            beerex_empty.out_eec_spray = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_ad_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.empirical_residue = pd.Series([&quot;yes&quot;, &quot;yes&quot;])<br/>            beerex_empty.ad_pollen = pd.Series([2.4, 36.5])<br/>            beerex_empty.ad_nectar = pd.Series([22.8, 2.1])<br/>            beerex_empty.application_rate = pd.Series([8.9, 0.88])<br/>            beerex_empty.empirical_nectar = pd.Series([1.2, 13.4])<br/>            beerex_empty.empirical_pollen = pd.Series([0.7, 2.2])<br/>            beerex_empty.n_runs = len(expected_results)<br/>            for i in range(len(expected_results)):<br/>&gt;               beerex_empty.eec_spray(i)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:657: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/>ubertool\ubertool\beerex\beerex_exe.py:240: in eec_spray<br/>    self.out_eec_soil[i] = np.nan<br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:793: in __setitem__<br/>    setitem(key, value)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>            self._set_with_engine(key, value)<br/>            return<br/>        except (SettingWithCopyError):<br/>            raise<br/>        except (KeyError, ValueError):<br/>            values = self._values<br/>            if (is_integer(key) and<br/>                    not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>&gt;               values[key] = value<br/><span class="error">E               IndexError: index 0 is out of bounds for axis 0 with size 0</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:750: IndexError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aq_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = Series([], Name: out_eec_seed, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>&gt;           self.index._engine.set_value(values, key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:800: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:101: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:109: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>&gt;               return self._engine.get_loc(key)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>&gt;           self._set_with_engine(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:741: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_seed, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>            self.index._engine.set_value(values, key, value)<br/>            return<br/>        except KeyError:<br/>&gt;           values[self.index.get_loc(key)] = value<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:803: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>                return self._engine.get_loc(key)<br/>            except KeyError:<br/>&gt;               return self._engine.get_loc(self._maybe_cast_indexer(key))<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2527: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aq_total_dose&gt;<br/><br/>    def test_beerex_aq_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aq_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aq_total_dose = (self.out_eec_method/100.) * self.aq_jelly<br/>        # self.out_eec_soil = ((10**(0.95*self.log_kow-2.05)+0.82) *<br/>        #                     (-0.0648*(self.log_kow**2)+0.2431*self.log_kow+0.5822) *<br/>        #                     (1.5/(0.2+1.5*self.koc*0.01)) * (0.5 * self.application_rate)) / 1000<br/>        try:<br/>            expected_results = [-85.7931737, 0.021943272]<br/>            beerex_empty.out_eec_soil = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_aq_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.n_runs = len(expected_results)<br/>            beerex_empty.empirical_residue = pd.Series([&quot;no&quot;, &quot;no&quot;])<br/>            beerex_empty.aq_jelly = pd.Series([223., 68.7])<br/>            beerex_empty.log_kow = pd.Series([6.3, 2.4])<br/>            beerex_empty.koc = pd.Series([4.1, 25.4])<br/>            beerex_empty.application_rate = pd.Series([3.4, 12.4])<br/>            for i in range(len(expected_results)):<br/>&gt;               beerex_empty.eec_soil(i)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:688: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.beerex_exe.Beerex object at 0x000001EF55F72470&gt;<br/>i = 0<br/><br/>    def eec_soil(self, i):<br/>        &quot;&quot;&quot;<br/>            EEC for soil application<br/>            &quot;&quot;&quot;<br/>        self.out_eec_soil[i] = ((10.**(0.95*self.log_kow[i]-2.05)+0.82) *<br/>                             (-0.0648*(self.log_kow[i]**2)+0.2431*self.log_kow[i]+0.5822) *<br/>                             (1.5/(0.2+1.5*self.koc[i]*0.01)) * (0.5 * self.application_rate[i])) / 1000.<br/>        self.out_eec_spray[i] = np.nan<br/>&gt;       self.out_eec_seed[i] = np.nan<br/><br/>ubertool\ubertool\beerex\beerex_exe.py:253: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_seed, dtype: float64), key = 0, value = nan<br/><br/>    def __setitem__(self, key, value):<br/>        key = com._apply_if_callable(key, self)<br/>    <br/>        def setitem(key, value):<br/>            try:<br/>                self._set_with_engine(key, value)<br/>                return<br/>            except (SettingWithCopyError):<br/>                raise<br/>            except (KeyError, ValueError):<br/>                values = self._values<br/>                if (is_integer(key) and<br/>                        not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>                    values[key] = value<br/>                    return<br/>                elif key is Ellipsis:<br/>                    self[:] = value<br/>                    return<br/>                elif com.is_bool_indexer(key):<br/>                    pass<br/>                elif is_timedelta64_dtype(self.dtype):<br/>                    # reassign a null value to iNaT<br/>                    if isna(value):<br/>                        value = iNaT<br/>    <br/>                        try:<br/>                            self.index._engine.set_value(self._values, key,<br/>                                                         value)<br/>                            return<br/>                        except TypeError:<br/>                            pass<br/>    <br/>                self.loc[key] = value<br/>                return<br/>    <br/>            except TypeError as e:<br/>                if (isinstance(key, tuple) and<br/>                        not isinstance(self.index, MultiIndex)):<br/>                    raise ValueError(&quot;Can only tuple-index with a MultiIndex&quot;)<br/>    <br/>                # python 3 type errors should be raised<br/>                if _is_unorderable_exception(e):<br/>                    raise IndexError(key)<br/>    <br/>            if com.is_bool_indexer(key):<br/>                key = check_bool_indexer(self.index, key)<br/>                try:<br/>                    self._where(~key, value, inplace=True)<br/>                    return<br/>                except InvalidIndexError:<br/>                    pass<br/>    <br/>            self._set_with(key, value)<br/>    <br/>        # do the setitem<br/>        cacher_needs_updating = self._check_is_chained_assignment_possible()<br/>&gt;       setitem(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:793: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>            self._set_with_engine(key, value)<br/>            return<br/>        except (SettingWithCopyError):<br/>            raise<br/>        except (KeyError, ValueError):<br/>            values = self._values<br/>            if (is_integer(key) and<br/>                    not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>&gt;               values[key] = value<br/><span class="error">E               IndexError: index 0 is out of bounds for axis 0 with size 0</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:750: IndexError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aq_total_dose&gt;<br/><br/>    def test_beerex_aq_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aq_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aq_total_dose = (self.out_eec_method/100.) * self.aq_jelly<br/>        # self.out_eec_soil = ((10**(0.95*self.log_kow-2.05)+0.82) *<br/>        #                     (-0.0648*(self.log_kow**2)+0.2431*self.log_kow+0.5822) *<br/>        #                     (1.5/(0.2+1.5*self.koc*0.01)) * (0.5 * self.application_rate)) / 1000<br/>        try:<br/>            expected_results = [-85.7931737, 0.021943272]<br/>            beerex_empty.out_eec_soil = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_aq_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.n_runs = len(expected_results)<br/>            beerex_empty.empirical_residue = pd.Series([&quot;no&quot;, &quot;no&quot;])<br/>            beerex_empty.aq_jelly = pd.Series([223., 68.7])<br/>            beerex_empty.log_kow = pd.Series([6.3, 2.4])<br/>            beerex_empty.koc = pd.Series([4.1, 25.4])<br/>            beerex_empty.application_rate = pd.Series([3.4, 12.4])<br/>            for i in range(len(expected_results)):<br/>                beerex_empty.eec_soil(i)<br/>                beerex_empty.out_eec = beerex_empty.out_eec_soil<br/>                beerex_empty.aq_total_dose()<br/>            result = beerex_empty.out_aq_total_dose<br/>            npt.assert_array_almost_equal(result, expected_results, 4, &#x27;&#x27;, True)<br/>        finally:<br/>&gt;           tab = [result, expected_results]<br/><span class="error">E           UnboundLocalError: local variable &#x27;result&#x27; referenced before assignment</span><br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:694: UnboundLocalError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_brood_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = Series([], Name: out_eec_seed, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>&gt;           self.index._engine.set_value(values, key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:800: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:101: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:109: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>&gt;               return self._engine.get_loc(key)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>&gt;           self._set_with_engine(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:741: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_seed, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>            self.index._engine.set_value(values, key, value)<br/>            return<br/>        except KeyError:<br/>&gt;           values[self.index.get_loc(key)] = value<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:803: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>                return self._engine.get_loc(key)<br/>            except KeyError:<br/>&gt;               return self._engine.get_loc(self._maybe_cast_indexer(key))<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2527: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aw_brood_total_dose&gt;<br/><br/>    def test_beerex_aw_brood_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aw_brood_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aw_brood_total_dose = (self.out_eec_method * self.aw_brood_nectar) + (self.out_eec_method * self.aw_brood_pollen)<br/>        try:<br/>            expected_results = [23.0725, 6.5472]<br/>            beerex_empty.out_aw_brood_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec_spray = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.aw_brood_pollen = pd.Series([5.7, 6.5])<br/>            beerex_empty.aw_brood_nectar = pd.Series([78.2, 43.1])<br/>            beerex_empty.application_rate = pd.Series([2.5, 1.2])<br/>            beerex_empty.n_runs = len(expected_results)<br/>            beerex_empty.empirical_residue = ([&quot;no&quot;, &quot;no&quot;])<br/>            for i in range(len(expected_results)):<br/>&gt;               beerex_empty.eec_spray(i)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:511: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.beerex_exe.Beerex object at 0x000001EF55F72470&gt;<br/>i = 0<br/><br/>    def eec_spray(self, i):<br/>        &quot;&quot;&quot;<br/>            EEC for foliar spray<br/>            &quot;&quot;&quot;<br/>        self.out_eec_spray[i] = (110. * self.application_rate[i]) / 1000<br/>        self.out_eec_soil[i] = np.nan<br/>&gt;       self.out_eec_seed[i] = np.nan<br/><br/>ubertool\ubertool\beerex\beerex_exe.py:241: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_seed, dtype: float64), key = 0, value = nan<br/><br/>    def __setitem__(self, key, value):<br/>        key = com._apply_if_callable(key, self)<br/>    <br/>        def setitem(key, value):<br/>            try:<br/>                self._set_with_engine(key, value)<br/>                return<br/>            except (SettingWithCopyError):<br/>                raise<br/>            except (KeyError, ValueError):<br/>                values = self._values<br/>                if (is_integer(key) and<br/>                        not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>                    values[key] = value<br/>                    return<br/>                elif key is Ellipsis:<br/>                    self[:] = value<br/>                    return<br/>                elif com.is_bool_indexer(key):<br/>                    pass<br/>                elif is_timedelta64_dtype(self.dtype):<br/>                    # reassign a null value to iNaT<br/>                    if isna(value):<br/>                        value = iNaT<br/>    <br/>                        try:<br/>                            self.index._engine.set_value(self._values, key,<br/>                                                         value)<br/>                            return<br/>                        except TypeError:<br/>                            pass<br/>    <br/>                self.loc[key] = value<br/>                return<br/>    <br/>            except TypeError as e:<br/>                if (isinstance(key, tuple) and<br/>                        not isinstance(self.index, MultiIndex)):<br/>                    raise ValueError(&quot;Can only tuple-index with a MultiIndex&quot;)<br/>    <br/>                # python 3 type errors should be raised<br/>                if _is_unorderable_exception(e):<br/>                    raise IndexError(key)<br/>    <br/>            if com.is_bool_indexer(key):<br/>                key = check_bool_indexer(self.index, key)<br/>                try:<br/>                    self._where(~key, value, inplace=True)<br/>                    return<br/>                except InvalidIndexError:<br/>                    pass<br/>    <br/>            self._set_with(key, value)<br/>    <br/>        # do the setitem<br/>        cacher_needs_updating = self._check_is_chained_assignment_possible()<br/>&gt;       setitem(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:793: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>            self._set_with_engine(key, value)<br/>            return<br/>        except (SettingWithCopyError):<br/>            raise<br/>        except (KeyError, ValueError):<br/>            values = self._values<br/>            if (is_integer(key) and<br/>                    not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>&gt;               values[key] = value<br/><span class="error">E               IndexError: index 0 is out of bounds for axis 0 with size 0</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:750: IndexError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aw_brood_total_dose&gt;<br/><br/>    def test_beerex_aw_brood_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aw_brood_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aw_brood_total_dose = (self.out_eec_method * self.aw_brood_nectar) + (self.out_eec_method * self.aw_brood_pollen)<br/>        try:<br/>            expected_results = [23.0725, 6.5472]<br/>            beerex_empty.out_aw_brood_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec_spray = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.aw_brood_pollen = pd.Series([5.7, 6.5])<br/>            beerex_empty.aw_brood_nectar = pd.Series([78.2, 43.1])<br/>            beerex_empty.application_rate = pd.Series([2.5, 1.2])<br/>            beerex_empty.n_runs = len(expected_results)<br/>            beerex_empty.empirical_residue = ([&quot;no&quot;, &quot;no&quot;])<br/>            for i in range(len(expected_results)):<br/>                beerex_empty.eec_spray(i)<br/>                beerex_empty.out_eec = beerex_empty.out_eec_spray<br/>                beerex_empty.aw_brood_total_dose()<br/>            result = beerex_empty.out_aw_brood_total_dose<br/>            npt.assert_array_almost_equal(result, expected_results, 4, &#x27;&#x27;, True)<br/>        finally:<br/>&gt;           tab = [result, expected_results]<br/><span class="error">E           UnboundLocalError: local variable &#x27;result&#x27; referenced before assignment</span><br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:517: UnboundLocalError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_cell_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = Series([], Name: out_eec_tree, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>&gt;           self.index._engine.set_value(values, key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:800: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:101: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:109: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>&gt;               return self._engine.get_loc(key)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>&gt;           self._set_with_engine(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:741: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_tree, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>            self.index._engine.set_value(values, key, value)<br/>            return<br/>        except KeyError:<br/>&gt;           values[self.index.get_loc(key)] = value<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:803: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>                return self._engine.get_loc(key)<br/>            except KeyError:<br/>&gt;               return self._engine.get_loc(self._maybe_cast_indexer(key))<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2527: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aw_cell_total_dose&gt;<br/><br/>    def test_beerex_aw_cell_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aw_cell_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aw_cell_total_dose = (self.out_eec_method * self.aw_cell_nectar) + (self.out_eec_method * self.aw_cell_pollen)<br/>        try:<br/>            expected_results = [0.0037, 0.0176]<br/>            beerex_empty.aw_cell_pollen = pd.Series([2.4, 12.3])<br/>            beerex_empty.aw_cell_nectar = pd.Series([1.3, 5.3])<br/>            beerex_empty.empirical_residue = ([&quot;no&quot;, &quot;no&quot;])<br/>            beerex_empty.out_aw_cell_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec_seed = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.n_runs = len(expected_results)<br/>            for i in range(len(expected_results)):<br/>&gt;               beerex_empty.eec_seed(i)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:484: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.beerex_exe.Beerex object at 0x000001EF55F72470&gt;<br/>i = 0<br/><br/>    def eec_seed(self, i):<br/>        &quot;&quot;&quot;<br/>            EEC for seed treatment<br/>            &quot;&quot;&quot;<br/>        self.out_eec_seed[i] = 1./1000.<br/>        self.out_eec_soil[i] = np.nan<br/>        self.out_eec_spray[i] = np.nan<br/>&gt;       self.out_eec_tree[i] = np.nan<br/><br/>ubertool\ubertool\beerex\beerex_exe.py:264: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_tree, dtype: float64), key = 0, value = nan<br/><br/>    def __setitem__(self, key, value):<br/>        key = com._apply_if_callable(key, self)<br/>    <br/>        def setitem(key, value):<br/>            try:<br/>                self._set_with_engine(key, value)<br/>                return<br/>            except (SettingWithCopyError):<br/>                raise<br/>            except (KeyError, ValueError):<br/>                values = self._values<br/>                if (is_integer(key) and<br/>                        not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>                    values[key] = value<br/>                    return<br/>                elif key is Ellipsis:<br/>                    self[:] = value<br/>                    return<br/>                elif com.is_bool_indexer(key):<br/>                    pass<br/>                elif is_timedelta64_dtype(self.dtype):<br/>                    # reassign a null value to iNaT<br/>                    if isna(value):<br/>                        value = iNaT<br/>    <br/>                        try:<br/>                            self.index._engine.set_value(self._values, key,<br/>                                                         value)<br/>                            return<br/>                        except TypeError:<br/>                            pass<br/>    <br/>                self.loc[key] = value<br/>                return<br/>    <br/>            except TypeError as e:<br/>                if (isinstance(key, tuple) and<br/>                        not isinstance(self.index, MultiIndex)):<br/>                    raise ValueError(&quot;Can only tuple-index with a MultiIndex&quot;)<br/>    <br/>                # python 3 type errors should be raised<br/>                if _is_unorderable_exception(e):<br/>                    raise IndexError(key)<br/>    <br/>            if com.is_bool_indexer(key):<br/>                key = check_bool_indexer(self.index, key)<br/>                try:<br/>                    self._where(~key, value, inplace=True)<br/>                    return<br/>                except InvalidIndexError:<br/>                    pass<br/>    <br/>            self._set_with(key, value)<br/>    <br/>        # do the setitem<br/>        cacher_needs_updating = self._check_is_chained_assignment_possible()<br/>&gt;       setitem(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:793: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>            self._set_with_engine(key, value)<br/>            return<br/>        except (SettingWithCopyError):<br/>            raise<br/>        except (KeyError, ValueError):<br/>            values = self._values<br/>            if (is_integer(key) and<br/>                    not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>&gt;               values[key] = value<br/><span class="error">E               IndexError: index 0 is out of bounds for axis 0 with size 0</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:750: IndexError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aw_cell_total_dose&gt;<br/><br/>    def test_beerex_aw_cell_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aw_cell_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aw_cell_total_dose = (self.out_eec_method * self.aw_cell_nectar) + (self.out_eec_method * self.aw_cell_pollen)<br/>        try:<br/>            expected_results = [0.0037, 0.0176]<br/>            beerex_empty.aw_cell_pollen = pd.Series([2.4, 12.3])<br/>            beerex_empty.aw_cell_nectar = pd.Series([1.3, 5.3])<br/>            beerex_empty.empirical_residue = ([&quot;no&quot;, &quot;no&quot;])<br/>            beerex_empty.out_aw_cell_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec_seed = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.n_runs = len(expected_results)<br/>            for i in range(len(expected_results)):<br/>                beerex_empty.eec_seed(i)<br/>                beerex_empty.out_eec = beerex_empty.out_eec_seed<br/>                beerex_empty.aw_cell_total_dose()<br/>            result = beerex_empty.out_aw_cell_total_dose<br/>            npt.assert_array_almost_equal(result, expected_results, 4, &#x27;&#x27;, True)<br/>        finally:<br/>&gt;           tab = [result, expected_results]<br/><span class="error">E           UnboundLocalError: local variable &#x27;result&#x27; referenced before assignment</span><br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:490: UnboundLocalError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_comb_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = Series([], Name: out_eec_tree, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>&gt;           self.index._engine.set_value(values, key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:800: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:101: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:109: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>&gt;               return self._engine.get_loc(key)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>&gt;           self._set_with_engine(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:741: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_tree, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>            self.index._engine.set_value(values, key, value)<br/>            return<br/>        except KeyError:<br/>&gt;           values[self.index.get_loc(key)] = value<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:803: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>                return self._engine.get_loc(key)<br/>            except KeyError:<br/>&gt;               return self._engine.get_loc(self._maybe_cast_indexer(key))<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2527: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aw_comb_total_dose&gt;<br/><br/>    def test_beerex_aw_comb_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aw_comb_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aw_comb_total_dose = (self.out_eec_method * self.aw_comb_nectar) + (self.out_eec_method * self.aw_comb_pollen)<br/>        # self.out_eec_soil = ((10**(0.95*self.log_kow-2.05)+0.82) *<br/>        #                     (-0.0648*(self.log_kow**2)+0.2431*self.log_kow+0.5822) *<br/>        #                     (1.5/(0.2+1.5*self.koc*0.01)) * (0.5 * self.application_rate)) / 1000<br/>        try:<br/>            expected_results = [1.2011859, 0.118363]<br/>            beerex_empty.aw_comb_pollen = pd.Series([6.2, 35.1])<br/>            beerex_empty.aw_comb_nectar = pd.Series([25.9, 12.4])<br/>            beerex_empty.log_kow = pd.Series([3.4, 0.63])<br/>            beerex_empty.koc = pd.Series([16.2, 2.5])<br/>            beerex_empty.application_rate = pd.Series([2.1, 1.3])<br/>            beerex_empty.empirical_residue = ([&quot;no&quot;, &quot;no&quot;])<br/>            beerex_empty.out_aw_comb_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec_soil = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.n_runs = len(expected_results)<br/>            for i in range(len(expected_results)):<br/>&gt;               beerex_empty.eec_soil(i)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:543: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.beerex_exe.Beerex object at 0x000001EF55F72470&gt;<br/>i = 0<br/><br/>    def eec_soil(self, i):<br/>        &quot;&quot;&quot;<br/>            EEC for soil application<br/>            &quot;&quot;&quot;<br/>        self.out_eec_soil[i] = ((10.**(0.95*self.log_kow[i]-2.05)+0.82) *<br/>                             (-0.0648*(self.log_kow[i]**2)+0.2431*self.log_kow[i]+0.5822) *<br/>                             (1.5/(0.2+1.5*self.koc[i]*0.01)) * (0.5 * self.application_rate[i])) / 1000.<br/>        self.out_eec_spray[i] = np.nan<br/>        self.out_eec_seed[i] = np.nan<br/>&gt;       self.out_eec_tree[i] = np.nan<br/><br/>ubertool\ubertool\beerex\beerex_exe.py:254: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_tree, dtype: float64), key = 0, value = nan<br/><br/>    def __setitem__(self, key, value):<br/>        key = com._apply_if_callable(key, self)<br/>    <br/>        def setitem(key, value):<br/>            try:<br/>                self._set_with_engine(key, value)<br/>                return<br/>            except (SettingWithCopyError):<br/>                raise<br/>            except (KeyError, ValueError):<br/>                values = self._values<br/>                if (is_integer(key) and<br/>                        not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>                    values[key] = value<br/>                    return<br/>                elif key is Ellipsis:<br/>                    self[:] = value<br/>                    return<br/>                elif com.is_bool_indexer(key):<br/>                    pass<br/>                elif is_timedelta64_dtype(self.dtype):<br/>                    # reassign a null value to iNaT<br/>                    if isna(value):<br/>                        value = iNaT<br/>    <br/>                        try:<br/>                            self.index._engine.set_value(self._values, key,<br/>                                                         value)<br/>                            return<br/>                        except TypeError:<br/>                            pass<br/>    <br/>                self.loc[key] = value<br/>                return<br/>    <br/>            except TypeError as e:<br/>                if (isinstance(key, tuple) and<br/>                        not isinstance(self.index, MultiIndex)):<br/>                    raise ValueError(&quot;Can only tuple-index with a MultiIndex&quot;)<br/>    <br/>                # python 3 type errors should be raised<br/>                if _is_unorderable_exception(e):<br/>                    raise IndexError(key)<br/>    <br/>            if com.is_bool_indexer(key):<br/>                key = check_bool_indexer(self.index, key)<br/>                try:<br/>                    self._where(~key, value, inplace=True)<br/>                    return<br/>                except InvalidIndexError:<br/>                    pass<br/>    <br/>            self._set_with(key, value)<br/>    <br/>        # do the setitem<br/>        cacher_needs_updating = self._check_is_chained_assignment_possible()<br/>&gt;       setitem(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:793: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>            self._set_with_engine(key, value)<br/>            return<br/>        except (SettingWithCopyError):<br/>            raise<br/>        except (KeyError, ValueError):<br/>            values = self._values<br/>            if (is_integer(key) and<br/>                    not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>&gt;               values[key] = value<br/><span class="error">E               IndexError: index 0 is out of bounds for axis 0 with size 0</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:750: IndexError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aw_comb_total_dose&gt;<br/><br/>    def test_beerex_aw_comb_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aw_comb_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aw_comb_total_dose = (self.out_eec_method * self.aw_comb_nectar) + (self.out_eec_method * self.aw_comb_pollen)<br/>        # self.out_eec_soil = ((10**(0.95*self.log_kow-2.05)+0.82) *<br/>        #                     (-0.0648*(self.log_kow**2)+0.2431*self.log_kow+0.5822) *<br/>        #                     (1.5/(0.2+1.5*self.koc*0.01)) * (0.5 * self.application_rate)) / 1000<br/>        try:<br/>            expected_results = [1.2011859, 0.118363]<br/>            beerex_empty.aw_comb_pollen = pd.Series([6.2, 35.1])<br/>            beerex_empty.aw_comb_nectar = pd.Series([25.9, 12.4])<br/>            beerex_empty.log_kow = pd.Series([3.4, 0.63])<br/>            beerex_empty.koc = pd.Series([16.2, 2.5])<br/>            beerex_empty.application_rate = pd.Series([2.1, 1.3])<br/>            beerex_empty.empirical_residue = ([&quot;no&quot;, &quot;no&quot;])<br/>            beerex_empty.out_aw_comb_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec_soil = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.n_runs = len(expected_results)<br/>            for i in range(len(expected_results)):<br/>                beerex_empty.eec_soil(i)<br/>                beerex_empty.out_eec = beerex_empty.out_eec_soil<br/>                beerex_empty.aw_comb_total_dose()<br/>            result = beerex_empty.out_aw_comb_total_dose<br/>            npt.assert_array_almost_equal(result, expected_results, 4, &#x27;&#x27;, True)<br/>        finally:<br/>&gt;           tab = [result, expected_results]<br/><span class="error">E           UnboundLocalError: local variable &#x27;result&#x27; referenced before assignment</span><br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:549: UnboundLocalError<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-result">Failed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_nectar_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">self = Series([], Name: out_eec_tree, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>&gt;           self.index._engine.set_value(values, key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:800: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:101: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:109: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>&gt;               return self._engine.get_loc(key)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2525: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>&gt;           self._set_with_engine(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:741: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_tree, dtype: float64), key = 0, value = nan<br/><br/>    def _set_with_engine(self, key, value):<br/>        values = self._values<br/>        try:<br/>            self.index._engine.set_value(values, key, value)<br/>            return<br/>        except KeyError:<br/>&gt;           values[self.index.get_loc(key)] = value<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:803: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Index([], dtype=&#x27;object&#x27;), key = 0, method = None, tolerance = None<br/><br/>    @Appender(_index_shared_docs[&#x27;get_loc&#x27;])<br/>    def get_loc(self, key, method=None, tolerance=None):<br/>        if method is None:<br/>            if tolerance is not None:<br/>                raise ValueError(&#x27;tolerance argument only valid if using pad, &#x27;<br/>                                 &#x27;backfill or nearest lookups&#x27;)<br/>            try:<br/>                return self._engine.get_loc(key)<br/>            except KeyError:<br/>&gt;               return self._engine.get_loc(self._maybe_cast_indexer(key))<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\indexes\base.py:2527: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:117: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/index.pyx:139: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><br/>pandas/_libs/hashtable_class_helper.pxi:1265: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>&gt;   ???<br/><span class="error">E   KeyError: 0</span><br/><br/>pandas/_libs/hashtable_class_helper.pxi:1273: KeyError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aw_nectar_total_dose&gt;<br/><br/>    def test_beerex_aw_nectar_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aw_nectar_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aw_nectar_total_dose = (self.out_eec_method * self.aw_fnectar_nectar) + (self.out_eec_method * self.aw_fnectar_pollen)<br/>        try:<br/>            expected_results = [0.0273, 0.0296]<br/>            beerex_empty.aw_fnectar_pollen = pd.Series([3.8, 16.9])<br/>            beerex_empty.aw_fnectar_nectar = pd.Series([23.5, 12.7])<br/>            beerex_empty.out_aw_nectar_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec_seed = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.n_runs = len(expected_results)<br/>            beerex_empty.empirical_residue = ([&quot;no&quot;, &quot;no&quot;])<br/>            for i in range(len(expected_results)):<br/>&gt;               beerex_empty.eec_seed(i)<br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:596: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.beerex_exe.Beerex object at 0x000001EF55F72470&gt;<br/>i = 0<br/><br/>    def eec_seed(self, i):<br/>        &quot;&quot;&quot;<br/>            EEC for seed treatment<br/>            &quot;&quot;&quot;<br/>        self.out_eec_seed[i] = 1./1000.<br/>        self.out_eec_soil[i] = np.nan<br/>        self.out_eec_spray[i] = np.nan<br/>&gt;       self.out_eec_tree[i] = np.nan<br/><br/>ubertool\ubertool\beerex\beerex_exe.py:264: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>self = Series([], Name: out_eec_tree, dtype: float64), key = 0, value = nan<br/><br/>    def __setitem__(self, key, value):<br/>        key = com._apply_if_callable(key, self)<br/>    <br/>        def setitem(key, value):<br/>            try:<br/>                self._set_with_engine(key, value)<br/>                return<br/>            except (SettingWithCopyError):<br/>                raise<br/>            except (KeyError, ValueError):<br/>                values = self._values<br/>                if (is_integer(key) and<br/>                        not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>                    values[key] = value<br/>                    return<br/>                elif key is Ellipsis:<br/>                    self[:] = value<br/>                    return<br/>                elif com.is_bool_indexer(key):<br/>                    pass<br/>                elif is_timedelta64_dtype(self.dtype):<br/>                    # reassign a null value to iNaT<br/>                    if isna(value):<br/>                        value = iNaT<br/>    <br/>                        try:<br/>                            self.index._engine.set_value(self._values, key,<br/>                                                         value)<br/>                            return<br/>                        except TypeError:<br/>                            pass<br/>    <br/>                self.loc[key] = value<br/>                return<br/>    <br/>            except TypeError as e:<br/>                if (isinstance(key, tuple) and<br/>                        not isinstance(self.index, MultiIndex)):<br/>                    raise ValueError(&quot;Can only tuple-index with a MultiIndex&quot;)<br/>    <br/>                # python 3 type errors should be raised<br/>                if _is_unorderable_exception(e):<br/>                    raise IndexError(key)<br/>    <br/>            if com.is_bool_indexer(key):<br/>                key = check_bool_indexer(self.index, key)<br/>                try:<br/>                    self._where(~key, value, inplace=True)<br/>                    return<br/>                except InvalidIndexError:<br/>                    pass<br/>    <br/>            self._set_with(key, value)<br/>    <br/>        # do the setitem<br/>        cacher_needs_updating = self._check_is_chained_assignment_possible()<br/>&gt;       setitem(key, value)<br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:793: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _<br/><br/>key = 0, value = nan<br/><br/>    def setitem(key, value):<br/>        try:<br/>            self._set_with_engine(key, value)<br/>            return<br/>        except (SettingWithCopyError):<br/>            raise<br/>        except (KeyError, ValueError):<br/>            values = self._values<br/>            if (is_integer(key) and<br/>                    not self.index.inferred_type == &#x27;integer&#x27;):<br/>    <br/>&gt;               values[key] = value<br/><span class="error">E               IndexError: index 0 is out of bounds for axis 0 with size 0</span><br/><br/>C:\Users\jminucci\AppData\Local\Continuum\Anaconda3\lib\site-packages\pandas\core\series.py:750: IndexError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;qed_pram.ubertool_ecorest.ubertool.ubertool.beerex.tests.test_beerex_unittest.TestBeerex testMethod=test_beerex_aw_nectar_total_dose&gt;<br/><br/>    def test_beerex_aw_nectar_total_dose(self):<br/>        &quot;&quot;&quot;<br/>            unittest for function beerex.aw_nectar_total_dose<br/>            &quot;&quot;&quot;<br/>        # self.out_aw_nectar_total_dose = (self.out_eec_method * self.aw_fnectar_nectar) + (self.out_eec_method * self.aw_fnectar_pollen)<br/>        try:<br/>            expected_results = [0.0273, 0.0296]<br/>            beerex_empty.aw_fnectar_pollen = pd.Series([3.8, 16.9])<br/>            beerex_empty.aw_fnectar_nectar = pd.Series([23.5, 12.7])<br/>            beerex_empty.out_aw_nectar_total_dose = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.out_eec_seed = pd.Series(np.nan, index=range(len(expected_results)), dtype=&quot;float&quot;)<br/>            beerex_empty.n_runs = len(expected_results)<br/>            beerex_empty.empirical_residue = ([&quot;no&quot;, &quot;no&quot;])<br/>            for i in range(len(expected_results)):<br/>                beerex_empty.eec_seed(i)<br/>                beerex_empty.out_eec = beerex_empty.out_eec_seed<br/>                beerex_empty.aw_nectar_total_dose()<br/>            result = beerex_empty.out_aw_nectar_total_dose<br/>            npt.assert_array_almost_equal(result, expected_results, 4, &#x27;&#x27;, True)<br/>        finally:<br/>&gt;           tab = [result, expected_results]<br/><span class="error">E           UnboundLocalError: local variable &#x27;result&#x27; referenced before assignment</span><br/><br/>ubertool\ubertool\beerex\tests\test_beerex_unittest.py:602: UnboundLocalError<br/></div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_assert_output_series</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>model output properties as pandas series
╒════╤═════╤═════╕
│    │   0 │   1 │
╞════╪═════╪═════╡
│  0 │   1 │   1 │
├────┼─────┼─────┤
│  1 │   1 │   1 │
├────┼─────┼─────┤
│  2 │   1 │   1 │
├────┼─────┼─────┤
│  3 │   1 │   1 │
├────┼─────┼─────┤
│  4 │   1 │   1 │
├────┼─────┼─────┤
│  5 │   1 │   1 │
├────┼─────┼─────┤
│  6 │   1 │   1 │
├────┼─────┼─────┤
│  7 │   1 │   1 │
├────┼─────┼─────┤
│  8 │   1 │   1 │
├────┼─────┼─────┤
│  9 │   1 │   1 │
├────┼─────┼─────┤
│ 10 │   1 │   1 │
├────┼─────┼─────┤
│ 11 │   1 │   1 │
├────┼─────┼─────┤
│ 12 │   1 │   1 │
├────┼─────┼─────┤
│ 13 │   1 │   1 │
├────┼─────┼─────┤
│ 14 │   1 │   1 │
├────┼─────┼─────┤
│ 15 │   1 │   1 │
├────┼─────┼─────┤
│ 16 │   1 │   1 │
├────┼─────┼─────┤
│ 17 │   1 │   1 │
├────┼─────┼─────┤
│ 18 │   1 │   1 │
├────┼─────┼─────┤
│ 19 │   1 │   1 │
├────┼─────┼─────┤
│ 20 │   1 │   1 │
├────┼─────┼─────┤
│ 21 │   1 │   1 │
├────┼─────┼─────┤
│ 22 │   1 │   1 │
├────┼─────┼─────┤
│ 23 │   1 │   1 │
├────┼─────┼─────┤
│ 24 │   1 │   1 │
├────┼─────┼─────┤
│ 25 │   1 │   1 │
├────┼─────┼─────┤
│ 26 │   1 │   1 │
├────┼─────┼─────┤
│ 27 │   1 │   1 │
├────┼─────┼─────┤
│ 28 │   1 │   1 │
├────┼─────┼─────┤
│ 29 │   1 │   1 │
├────┼─────┼─────┤
│ 30 │   1 │   1 │
├────┼─────┼─────┤
│ 31 │   1 │   1 │
├────┼─────┼─────┤
│ 32 │   1 │   1 │
├────┼─────┼─────┤
│ 33 │   1 │   1 │
├────┼─────┼─────┤
│ 34 │   1 │   1 │
├────┼─────┼─────┤
│ 35 │   1 │   1 │
├────┼─────┼─────┤
│ 36 │   1 │   1 │
├────┼─────┼─────┤
│ 37 │   1 │   1 │
├────┼─────┼─────┤
│ 38 │   1 │   1 │
├────┼─────┼─────┤
│ 39 │   1 │   1 │
├────┼─────┼─────┤
│ 40 │   1 │   1 │
├────┼─────┼─────┤
│ 41 │   1 │   1 │
├────┼─────┼─────┤
│ 42 │   1 │   1 │
├────┼─────┼─────┤
│ 43 │   1 │   1 │
├────┼─────┼─────┤
│ 44 │   1 │   1 │
├────┼─────┼─────┤
│ 45 │   1 │   1 │
├────┼─────┼─────┤
│ 46 │   1 │   1 │
├────┼─────┼─────┤
│ 47 │   1 │   1 │
├────┼─────┼─────┤
│ 48 │   1 │   1 │
├────┼─────┼─────┤
│ 49 │   1 │   1 │
├────┼─────┼─────┤
│ 50 │   1 │   1 │
├────┼─────┼─────┤
│ 51 │   1 │   1 │
├────┼─────┼─────┤
│ 52 │   1 │   1 │
├────┼─────┼─────┤
│ 53 │   1 │   1 │
├────┼─────┼─────┤
│ 54 │   1 │   1 │
├────┼─────┼─────┤
│ 55 │   1 │   1 │
├────┼─────┼─────┤
│ 56 │   1 │   1 │
├────┼─────┼─────┤
│ 57 │   1 │   1 │
├────┼─────┼─────┤
│ 58 │   1 │   1 │
╘════╧═════╧═════╛
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_integration.py::TestBeerex::test_assert_output_series_dtypes</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="empty log">No log output captured.</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_ad_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_ad_acute_rq
======  ========
     0         1
======  ========
4.4386  0.146497
4.4386  0.146497
======  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_ad_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_ad_chronic_rq
========  ========
       0         1
========  ========
0.440945  0.411765
0.440945  0.411765
========  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aq_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aq_acute_rq
=======  =========
      0          1
=======  =========
5.26613  0.0174419
5.26613  0.0174419
=======  =========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aq_chronic_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aq_chronic_rq
========  ===
       0    1
========  ===
0.226496   29
0.226496   29
========  ===
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_brood_acute_rq</td>
          <td class="col-duration">0.01</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_brood_acute_rq
=======  =======
      0        1
=======  =======
10.6818  1.82353
10.6818  1.82353
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_brood_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_brood_chronic_rq
========  =======
       0        1
========  =======
0.227273  2.80233
0.22727   2.80233
========  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_cell_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_cell_acute_rq
=======  ====
      0     1
=======  ====
6.15493  2.48
6.15493  2.48
=======  ====
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_cell_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_cell_chronic_rq
=======  =======
      0        1
=======  =======
3.65217  5.12069
3.65217  5.12069
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_comb_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_comb_acute_rq
=======  =======
      0        1
=======  =======
1.95031  1.23784
1.95031  1.23784
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_comb_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_comb_chronic_rq
===  ========
  0         1
===  ========
  4  0.747126
  4  0.747126
===  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_nectar_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_nectar_acute_rq
=======  ========
      0         1
=======  ========
4.83333  0.187919
4.83333  0.187919
=======  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_nectar_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_nectar_chronic_rq
========  =========
       0          1
========  =========
0.182171  0.0514706
0.182171  0.0514706
========  =========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_pollen_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_pollen_acute_rq
========  ======
       0       1
========  ======
0.884615  2.6378
0.884615  2.6378
========  ======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_pollen_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_pollen_chronic_rq
=======  =======
      0        1
=======  =======
1.72449  4.16279
1.72449  4.16279
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_pollen_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_pollen_total_dose
========  ===========
       0            1
========  ===========
0.015225  0.000689367
0.015225  0.000689367
========  ===========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_winter_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_winter_acute_rq
=========  =======
        0        1
=========  =======
0.0794118  1.14141
0.079411   1.14141
=========  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_winter_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_winter_chronic_rq
=======  =======
      0        1
=======  =======
7.94118  7.50806
7.94118  7.50806
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_aw_winter_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_aw_winter_total_dose
=========  ==========
        0           1
=========  ==========
0.0130733  0.00160364
0.0130733  0.00160364
=========  ==========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_eec_seed</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_eec_seed
===
0
===
[
0
..
..
..
1
.
0
0
0
0
E
-
0
3
..
1
..
..
..
1
.
0
0
0
0
E
-
0
3
..
d
t
y
p
e
:
..
f
l
o
a
t
6
4
,
..
[
0
.
0
0
1
,
..
0
.
0
0
1
]
]
===
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_eec_soil</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_eec_soil
=========  ==========
        0           1
=========  ==========
0.0222534  0.00378781
0.0222534  0.00378781
=========  ==========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_eec_tree</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_eec_tree
====  ==========
   0           1
====  ==========
0.01  0.00011157
0.01  0.00011157
====  ==========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_ld6_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_ld6_acute_rq
========  =======
       0        1
========  =======
0.782258  5.82143
0.782258  5.82143
========  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_ld6_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_ld6_chronic_rq
=======  =======
      0        1
=======  =======
1.34064  0.28125
1.34064  0.28125
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_ld6_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_ld6_total_dose
=========  ======
        0       1
=========  ======
0.0370804  0.0437
0.0370804  0.0437
=========  ======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq1_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq1_acute_rq
=====  ========
    0         1
=====  ========
1.742  0.206897
1.742  0.206897
=====  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq1_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq1_chronic_rq
=========  =======
        0        1
=========  =======
0.0789474  272.083
0.078947   272.083
=========  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq1_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq1_total_dose
===========  ===========
          0            1
===========  ===========
5.50588e-06  1.77455e-06
5.50588e-06  1.77455e-06
===========  ===========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq2_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq2_acute_rq
=======  ========
      0         1
=======  ========
1.77011  0.578947
1.77011  0.578947
=======  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq2_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq2_chronic_rq
=========  =========
        0          1
=========  =========
0.0588235  0.0161765
0.0588235  0.0161765
=========  =========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq2_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq2_total_dose
=======  =======
      0        1
=======  =======
6.5e-05  2.8e-05
6.5e-05  2.8e-05
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq3_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq3_acute_rq
=======  =======
      0        1
=======  =======
7.65979  1.66234
7.65979  1.66234
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq3_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq3_chronic_rq
========  ========
       0         1
========  ========
0.503448  0.440722
0.503448  0.440722
========  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq3_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq3_total_dose
========  ======
       0       1
========  ======
0.055055  0.0132
0.055055  0.0132
========  ======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq4_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq4_acute_rq
========  =======
       0        1
========  =======
0.362069  9.78261
0.362069  9.78261
========  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq4_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq4_chronic_rq
========  ========
       0         1
========  ========
0.169863  0.194118
0.169863  0.194118
========  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lq4_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lq4_total_dose
=======  =======
      0        1
=======  =======
0.15136  0.48521
0.15136  0.48521
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw1_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw1_acute_rq
=======  ========
      0         1
=======  ========
5.25926  0.349296
5.25926  0.349296
=======  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw1_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw1_chronic_rq
=======  ========
      0         1
=======  ========
3.22222  0.220126
3.22222  0.220126
=======  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw1_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw1_total_dose
=====  ========
    0         1
=====  ========
0.055  0.006765
0.055  0.006765
=====  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw2_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw2_acute_rq
========  =======
       0        1
========  =======
0.355705  2.13462
0.355705  2.13462
========  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw2_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw2_chronic_rq
=======  =======
      0        1
=======  =======
11.3696  2.76712
11.3696  2.76712
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw2_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw2_total_dose
=========  ===========
        0            1
=========  ===========
1.784e-06  7.38636e-06
1.784e-06  7.386e-06
=========  ===========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw3_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw3_acute_rq
=======  ========
      0         1
=======  ========
3.37356  0.207547
3.37356  0.207547
=======  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw3_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw3_chronic_rq
=======  =======
      0        1
=======  =======
2.47826  1.03165
2.47826  1.03165
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw3_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw3_total_dose
===========  ===========
          0            1
===========  ===========
0.000581992  0.000220323
0.00058199   0.000220323
===========  ===========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw4_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw4_acute_rq
=======  =======
      0        1
=======  =======
3.78261  1.57143
3.78261  1.57143
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw4_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw4_chronic_rq
=======  ======
      0       1
=======  ======
1.23707  32.625
1.23707  32.625
=======  ======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw4_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw4_total_dose
=======  ========
      0         1
=======  ========
0.04387  0.011578
0.04387  0.011578
=======  ========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw5_acute_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw5_acute_rq
=======  =======
      0        1
=======  =======
20.0833  2.67273
20.0833  2.67273
=======  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw5_chronic_rq</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw5_chronic_rq
=====  =========
    0          1
=====  =========
0.175  0.0168889
0.175  0.0168889
=====  =========
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_beerex_lw5_total_dose</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_beerex_lw5_total_dose
========  =======
       0        1
========  =======
0.032169  0.07042
0.032169  0.07042
========  =======
</div></td></tr></tbody>
      <tbody class="passed results-table-row">
        <tr>
          <td class="col-result">Passed</td>
          <td class="col-name">ubertool/ubertool/beerex/tests/test_beerex_unittest.py::TestBeerex::test_eec_spray</td>
          <td class="col-duration">0.00</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="4">
            <div class="log">----------------------------- Captured stdout call -----------------------------<br/>

test_eec_spray
===  =====
  0      1
===  =====
1.1  0.275
1.1  0.275
===  =====
</div></td></tr></tbody></table></body></html>